##########################################################################
# Pre-Facet-Image Production Pipeline                                    #
#                                                                        #
# Pipeline to do the imaging of the target data:                         #
# - intended for use in production runs                                  #
# - requires LOFAR software version >= 3.1.0                             #
# - requires WSClean software version >= 2.5                             #
# - expects shared filesystem, that all nodes can reach all files!       #
#   (E.g. a single workstation or compute cluster with shared filesystem #
#   doesn't work on multiple nodes on CEP3.)                             #
##########################################################################

## information about the input data
! data_input_filenames     =  []                                  ## list of input MS filenames (full path)

## information about the output
! image_output_filenames   =  []                                  ## list of output image filenames for feedback (full path)

## location of the software
! prefactor_directory      =  $PREFACTOR_PATH                     ## path to your prefactor copy
! wsclean_executable       =  $WSCLEAN_EXECUTABLE                 ## path to your local WSClean executable

## imaging parameters
! cellsize_highres_deg     =  0.00208                             ## cellsize in degrees, 0.00208 deg is about 7.5 arcsec
! fieldsize_highres        =  2.5                                 ## size of the image is this value times the FWHM of mean semi-major axis of the station beam
! maxlambda_highres        =  7000                                ## maximum uv-distance in lambda that will be used for imaging
! image_padding            =  1.4                                 ## how much padding shall we add during the imaging?
! axis_stretch             =  1.0                                 ## how much shall the y-axis be stretched or compressed?
! idg_mode                 =  hybrid                              ## IDG mode to use: cpu or hybrid (= CPU + GPU)

## pipeline performance
! max_imagers_per_node     =  2                                   ## number of simultaneous imager process per node
! max_percent_mem_per_img  =  45                                  ## max memory (as % of total) per imager process
! max_cpus_per_img         =  20                                  ## number of cpus per imager process
! error_tolerance          =  False                               ## set this to True if you want the pipeline run to continue if single bands fail

## main directories
! lofar_directory          =  $LOFARROOT                          ## base directory of your LOFAR installation
! job_directory            =  input.output.job_directory          ## directory of the prefactor outputs

## script and plugin directories
! scripts                  =  {{ prefactor_directory }}/scripts
pipeline.pluginpath        =  {{ prefactor_directory }}/plugins

## result and scratch directories
! local_scratch_dir        =  /tmp                                ## scratch directory for wsclean (can be local to the processing nodes!)
! images_metadata_file     =  input.output.working_directory/input.output.job_name/images.metadata
! parset_prefix            =  none

## image root name
! image_rootname           =  {{ job_directory }}/fullband        ## image root name

# which steps to run
pipeline.steps = [create_ms_map, combine_mapfile, do_magic, do_magic_maps, combine_mapfile_deep, wsclean_high_deep, copy_output_images, make_image_metadata]

# generate a mapfile of all the target data
create_ms_map.control.kind                           =   plugin
create_ms_map.control.type                           =   addListMapfile
create_ms_map.control.hosts                          =   [localhost]
create_ms_map.control.files                          =   {{ data_input_filenames }}
create_ms_map.control.check_files_exist              =   True
create_ms_map.control.check_ms_column                =   CORRECTED_DATA
create_ms_map.control.mapfile_dir                    =   input.output.mapfile_dir
create_ms_map.control.filename                       =   create_ms_map.mapfile

# generate a mapfile with all files in a single entry, length = 1
combine_mapfile.control.kind                         =  plugin
combine_mapfile.control.type                         =  createMapfile
combine_mapfile.control.method                       =  mapfile_all_to_one
combine_mapfile.control.mapfile_in                   =  create_ms_map.output.mapfile
combine_mapfile.control.mapfile_dir                  =  input.output.mapfile_dir
combine_mapfile.control.filename                     =  combine_mapfile.mapfile

# compute frequency groupings, image sizes, averaging values, etc., len = different
# the deep version of the do_magic_script should return mapfiles sorted by increasing frequency
do_magic.control.type                                =  pythonplugin
do_magic.control.executable                          =  {{ scripts }}/InitSubtract_deep_sort_and_compute.py
do_magic.argument.flags                              =  [combine_mapfile.output.mapfile]
do_magic.argument.outmapname                         =  do_magic.datamap
do_magic.argument.mapfile_dir                        =  input.output.mapfile_dir
do_magic.argument.cellsize_highres_deg               =  {{ cellsize_highres_deg }}
do_magic.argument.fieldsize_highres                  =  {{ fieldsize_highres }}
do_magic.argument.image_padding                      =  {{ image_padding }}
do_magic.argument.y_axis_stretch                     =  {{ axis_stretch }}

# convert the output of do_magic into usable mapfiles,len = 1 / different
do_magic_maps.control.kind                           =  plugin
do_magic_maps.control.type                           =  mapfilenamesFromMapfiles
do_magic_maps.control.mapfile_nbands_map             =  do_magic.output.nbands.mapfile
do_magic_maps.control.mapfile_nchansout_clean1_map   =  do_magic.output.nchansout_clean1.mapfile
do_magic_maps.control.mapfile_groupmap               =  do_magic.output.groupmap.mapfile
do_magic_maps.control.mapfile_single_map             =  do_magic.output.single_mapfile.mapfile
do_magic_maps.control.mapfile_deep_high_size_map     =  do_magic.output.deep_high_size_mapfile.mapfile

# generate a mapfile with all files in a single entry, length = 1
combine_mapfile_deep.control.kind                    =  plugin
combine_mapfile_deep.control.type                    =  createMapfile
combine_mapfile_deep.control.method                  =  mapfile_all_to_one
combine_mapfile_deep.control.mapfile_in              =  do_magic_maps.output.single_map
combine_mapfile_deep.control.mapfile_dir             =  input.output.mapfile_dir
combine_mapfile_deep.control.filename                =  combine_mapfile_deep.mapfile

# first high-res imaging, length = 1
# TODO: enable primary-beam correction for MFS image (add "-grid-with-beam" to inputkeys)
wsclean_high_deep.control.kind                      =   recipe
wsclean_high_deep.control.type                      =   executable_args
wsclean_high_deep.control.executable                =   {{ wsclean_executable }}
wsclean_high_deep.control.inplace                   =   True
wsclean_high_deep.control.args_format               =   wsclean
wsclean_high_deep.control.max_per_node              =   1
wsclean_high_deep.control.error_tolerance           =   {{ error_tolerance }}
wsclean_high_deep.control.mapfiles_in               =   [combine_mapfile_deep.output.mapfile,do_magic_maps.output.deep_high_size_map,do_magic_maps.output.nchansout_clean1_map]
wsclean_high_deep.control.inputkeys                 =   [msfile,outputsize,nchansout_clean1]
wsclean_high_deep.argument.flags                    =   [-no-update-model-required,-reorder,-fit-beam,-join-channels,-use-idg,msfile]
wsclean_high_deep.argument.name                     =   {{ image_rootname }}
wsclean_high_deep.argument.size                     =   outputsize
wsclean_high_deep.argument.padding                  =   {{ image_padding }}
wsclean_high_deep.argument.channels-out             =   nchansout_clean1
wsclean_high_deep.argument.niter                    =   100000
wsclean_high_deep.argument.threshold                =   0.0
wsclean_high_deep.argument.pol                      =   I
wsclean_high_deep.argument.weight                   =   briggs 0.0
wsclean_high_deep.argument.mgain                    =   0.65
wsclean_high_deep.argument.minuv-l                  =   80
wsclean_high_deep.argument.maxuv-l                  =   {{ maxlambda_highres }}
wsclean_high_deep.argument.scale                    =   {{ cellsize_highres_deg }}
wsclean_high_deep.argument.mem                      =   {{ max_percent_mem_per_img }}
wsclean_high_deep.argument.j                        =   {{ max_cpus_per_img }}
wsclean_high_deep.argument.weighting-rank-filter    =   3
wsclean_high_deep.argument.temp-dir                 =   {{ local_scratch_dir }}
wsclean_high_deep.argument.auto-mask                =   3.3
wsclean_high_deep.argument.auto-threshold           =   0.5
wsclean_high_deep.argument.local-rms-window         =   50
wsclean_high_deep.argument.local-rms-method         =   rms-with-min
wsclean_high_deep.argument.idg-mode                 =   {{ idg_mode }}

# create a map with the wsclean MFS image only, length = 1 (note: disabled until source list can be fed back)
# createmap_high_deep_image.control.kind              =   plugin
# createmap_high_deep_image.control.type              =   createMapfile
# createmap_high_deep_image.control.method            =   mapfile_from_folder
# createmap_high_deep_image.control.mapfile_dir       =   input.output.mapfile_dir
# createmap_high_deep_image.control.filename          =   wsclean_high_deep_image.mapfile
# createmap_high_deep_image.control.folder            =   input.output.working_directory/input.output.job_name
# createmap_high_deep_image.control.pattern           =   *wsclean_high_deep-MFS-image.fits

# make source list for the high-res image, length = 1 (note: disabled until source list can be fed back)
# Note: until image is primary-beam corrected, fluxes will be apparent
# make_source_list.control.type                       =   pythonplugin
# make_source_list.control.executable                 =   {{ scripts }}/make_source_list.py
# make_source_list.control.max_per_node               =   {{ max_imagers_per_node }}
# make_source_list.control.error_tolerance            =   {{ error_tolerance }}
# make_source_list.control.mapfile_in                 =   createmap_high_deep_image.output.mapfile
# make_source_list.control.inputkey                   =   imagefile
# make_source_list.control.outputkey                  =   catalogfile
# make_source_list.argument.flags                     =   [imagefile,catalogfile]
# make_source_list.argument.threshisl                 =   3.0
# make_source_list.argument.threshpix                 =   5.0
# make_source_list.argument.atrous_do                 =   True
# make_source_list.argument.rmsbox                    =   (60,20)
# make_source_list.argument.adaptive_rmsbox           =   True

# copy image to output filenames expected for feedback
copy_output_images.control.kind                     =   plugin
copy_output_images.control.type                     =   copyFiles
copy_output_images.control.hosts                    =   [localhost]
copy_output_images.control.input_file               =   {{ image_rootname }}-MFS-image.fits
copy_output_images.control.output_files             =   {{ image_output_filenames }}
copy_output_images.control.use_symlinks             =   True
copy_output_images.control.mapfile_dir              =   input.output.mapfile_dir
copy_output_images.control.filename                 =   output_images.mapfile

# make feedback metadata for the output image
make_image_metadata.control.kind                    =   feedback
make_image_metadata.control.mapfile_in              =   copy_output_images.output.mapfile
make_image_metadata.control.metadata_file           =   {{ images_metadata_file }}
make_image_metadata.control.product_type            =   SkyImage
make_image_metadata.control.parset_prefix           =   {{ parset_prefix }}
