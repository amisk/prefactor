##########################################################################
# Pre-Facet Target Calibration Pipeline                                  #
#                                                                        #
# Target part of the basic Pre-Facet calibration pipeline:               #
# - requires LOFAR software version  >= 3.1.0                            #
# - requires losoto software version >= 2.0.0                            #
# - expects shared filesystem, that all nodes can reach all files!       #
#   (E.g. a single workstation or compute cluster with shared filesystem #
#   doesn't work on multiple nodes on CEP3.)                             #
##########################################################################

##########################################
### parameters you will need to adjust. ##
##########################################

## information about the target data
! target_input_path         =  /data/scratch/drabent                  ## specify the directory where your target data is stored
! target_input_pattern      =  L228163*.MS                            ## regular expression pattern of all your target files

## location of the software
! prefactor_directory       =  /home/drabent/prefactor                ## path to your prefactor copy
! losoto_directory          =  /home/drabent/losoto                   ## path to your local LoSoTo installation
! aoflagger                 =  /opt/cep/aoflagger/aoflagger-2.10.0/build/bin/aoflagger ## path to your aoflagger executable

## location of the calibrator solutions
! cal_solutions             =  input.output.job_directory/../Pre-Facet-Calibrator/results/cal_values/cal_solutions.h5

##########################################
### parameters you may need to adjust   ##
##########################################

! refant                    = 'CS001HBA0'                             ## name of the station that will be used as a reference for the phase-plots
! flag_baselines            =  []                                     ## NDPPP-compatible pattern for baselines or stations to be flagged (may be an empty list, i.e.: [] )
! filter_baselines          =  [CR]S*&                                ## selects only this set of baselines to be processed. Choose [CR]S*& if you want to process only cross-correlations and remove international stations.
! do_smooth                 =  False                                  ## enable or disable baseline-based smoothing
! rfistrategy               =  HBAdefault                             ## strategy to be applied with the statistical flagger (AOFlagger)
! max_length                =  20                                     ## amount of subbands (calibrator) or chunks (target) to concatenate for full-bandwidth flagging (for calibrator you can take all SBs, for target stick to ~5 chunks for about 128 GB of RAM)
! interp_windowsize         =  15                                     ## Size of the window over which a value is interpolated. Should be odd.
! min_unflagged_fraction    =  0.5                                    ## minimum fraction of unflagged data after RFI flagging and A-team clipping

# definitions for pipeline options
! substep                   =  clipATeam,                             ## set empty if you want to skip A-Team clipping
##########################################
### parameters for pipeline performance ##
##########################################

! num_proc_per_node         =  input.output.max_per_node              ## number of processes to use per step per node (usually max_per_node from pipeline.cfg)
! num_proc_per_node_limit   =  4                                      ## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads          =  10                                     ## number of threads per process for NDPPP

! error_tolerance           =  False                                  ## set this to True if you want the pipeline run to continue if single bands fail

##########################################
### parameters you may want to adjust   ##
##########################################

## main directories
! lofar_directory           =  $LOFARROOT                             ## base directory of your LOFAR installation
! job_directory             =  input.output.job_directory             ## directory of the prefactor outputs

## script and plugin directories
! scripts                   =  {{ prefactor_directory }}/scripts
pipeline.pluginpath         =  {{ prefactor_directory }}/plugins

## skymodel directory
! target_skymodel           =  {{ job_directory }}/target.skymodel    ## path to the skymodel for the phase-only calibration of the target
! use_tgss_target           =  True                                   ## download the phase-only calibration skymodel from TGSS, "Force" : always download , "True" download if {{ target_skymodel }} does not exist , "False" : never download

## result directories
! results_directory         =  {{ job_directory }}/results            ## location of the results
! inspection_directory      =  {{ results_directory }}/inspection     ## directory where the inspection plots will be stored
! cal_values_directory      =  {{ results_directory }}/cal_values     ## directory where the final h5parm solution set will be stored

## calibrator + target solutions
! solutions                 =  {{ cal_values_directory }}/solutions.h5

## averaging for the target data
! avg_timeresolution        =  4.                                     ## average to 4 sec/timeslot
! avg_freqresolution        =  48.82kHz                               ## average to 48.82 kHz/ch (= 4 ch/SB)
! avg_timeresolution_concat =  8.                                     ## average to 8 sec/timeslot
! avg_freqresolution_concat =  97.64kHz                               ## average to 97.64 kHz/ch (= 2 ch/SB)

## concatenating the target data
! num_SBs_per_group         =  10                                     ## make concatenated measurement-sets with that many subbands
! reference_stationSB       =  None                                   ## station-subband number to use as reference for grouping, "None" -> use lowest frequency input data as reference

## RMextract settings
! ionex_server              =  "ftp://ftp.aiub.unibe.ch/CODE/"        ## to download from the "standard" server
! ionex_prefix              =  CODG                                   ## the prefix of the IONEX files
! ionex_path                =  {{ job_directory }}/IONEX/             ## path where the IONEX files can be stored or are already stored

########################################################
##                                                    ##
##    BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!  ##
##                                                    ##
########################################################

# which steps to run
pipeline.steps             =  [prep, {{ substep }} concat, gsmcal, finalize]

# pipeline substeps
pipeline.steps.prep        =  [createmap_target, combine_data_target_map, mk_targ_values_dir, copy_cal_sols, h5imp_RMextract, prepare_losoto_RMextract, process_losoto_RMextract, check_station_mismatch, ndppp_prep_target]
pipeline.steps.clipATeam   =  [create_ateam_model_map, make_sourcedb_ateam, expand_sourcedb_ateam, predict_ateam, ateamcliptar]
pipeline.steps.concat      =  [combine_target_map, sortmap_target, do_sortmap_maps, dpppconcat, combine_concat_map, ms_concat_target, ms_concat_target_map, aoflag]
pipeline.steps.gsmcal      =  [check_unflagged, check_bad_antennas, check_unflagged_map, sky_tar, create_target_model_map, make_sourcedb_target, expand_sourcedb_target, gsmcal_parmmap, h5_gsmsol_map, make_results_mapfile, gsmcal_solve_dysco, h5imp_gsmcal, prepare_losoto_gsmcal, process_losoto_gsmcal, h5exp_gsmcal]
pipeline.steps.finalize    =  [make_results_mapfile2, move_results]


#############################
## Prepare target part     ##
#############################

# generate a mapfile of all the target data
createmap_target.control.kind                                  =   plugin
createmap_target.control.type                                  =   createMapfile
createmap_target.control.method                                =   mapfile_from_folder
createmap_target.control.mapfile_dir                           =   input.output.mapfile_dir
createmap_target.control.filename                              =   createmap_target.mapfile
createmap_target.control.folder                                =   {{ target_input_path }}
createmap_target.control.pattern                               =   {{ target_input_pattern }}

# combine all entries into one mapfile, for the sortmap script
combine_data_target_map.control.kind                           =   plugin
combine_data_target_map.control.type                           =   createMapfile
combine_data_target_map.control.method                         =   mapfile_all_to_one
combine_data_target_map.control.mapfile_dir                    =   input.output.mapfile_dir
combine_data_target_map.control.filename                       =   combine_data_tar_map.mapfile
combine_data_target_map.control.mapfile_in                     =   createmap_target.output.mapfile

# create the cal_values_directory if needed
mk_targ_values_dir.control.kind                                =   plugin
mk_targ_values_dir.control.type                                =   makeDirectory
mk_targ_values_dir.control.directory                           =   {{ cal_values_directory }}

# move the results to where we want them
copy_cal_sols.control.kind                                     =   recipe
copy_cal_sols.control.type                                     =   executable_args
copy_cal_sols.control.executable                               =   /bin/cp
copy_cal_sols.control.max_per_node                             =   1
copy_cal_sols.control.skip_infile                              =   True
copy_cal_sols.control.mapfile_in                               =   combine_data_target_map.output.mapfile
copy_cal_sols.argument.flags                                   =   [{{ cal_solutions }},{{ solutions }}]

#############################
## RM target correction    ##
#############################
# get ionex files once for every day that is covered by one of the input MSs
h5imp_RMextract.control.type                                   =   pythonplugin
h5imp_RMextract.control.executable                             =   {{ scripts }}/createRMh5parm.py
h5imp_RMextract.control.error_tolerance                        =   {{ error_tolerance }}
h5imp_RMextract.argument.flags                                 =   [combine_data_target_map.output.mapfile, {{ solutions }}]
h5imp_RMextract.argument.ionex_server                          =   {{ ionex_server }}
h5imp_RMextract.argument.ionex_prefix                          =   {{ ionex_prefix }}
h5imp_RMextract.argument.ionexPath                             =   {{ ionex_path }}
h5imp_RMextract.argument.solset_name                           =   target
h5imp_RMextract.argument.all_stations                          =   True

# create losoto v2 parset file
prepare_losoto_RMextract.control.kind                          =   plugin
prepare_losoto_RMextract.control.type                          =   makeLosotoParset
prepare_losoto_RMextract.control.steps                         =   [plotRM]
prepare_losoto_RMextract.control.filename                      =   {{ job_directory }}/losoto.parset
prepare_losoto_RMextract.control.global.ncpu                   =   {{ num_proc_per_node }}
prepare_losoto_RMextract.control.plotRM.operation              =   PLOT
prepare_losoto_RMextract.control.plotRM.soltab                 =   target/RMextract
prepare_losoto_RMextract.control.plotRM.axesInPlot             =   time
prepare_losoto_RMextract.control.plotRM.axisInTable            =   ant
prepare_losoto_RMextract.control.plotRM.prefix                 =   {{ inspection_directory }}/RMextract

# do the processing on the LoSoTo file
process_losoto_RMextract.control.kind                          =   recipe
process_losoto_RMextract.control.type                          =   executable_args
process_losoto_RMextract.control.executable                    =   {{ losoto_directory }}/bin/losoto
process_losoto_RMextract.control.max_per_node                  =   {{ num_proc_per_node }}
process_losoto_RMextract.control.mapfile_in                    =   combine_data_target_map.output.mapfile
process_losoto_RMextract.control.inputkey                      =   input
process_losoto_RMextract.argument.flags                        =   [{{ solutions }}, {{ job_directory }}/losoto.parset]


#############################
## Apply calibrator sols   ##
#############################
# check potential station mismatch
check_station_mismatch.control.kind                            =   plugin
check_station_mismatch.control.type                            =   compareStationList
check_station_mismatch.control.mapfile_in                      =   createmap_target.output.mapfile
check_station_mismatch.control.h5parmdb                        =   {{ solutions }}
check_station_mismatch.control.solset_name                     =   calibrator
check_station_mismatch.control.filter                          =   {{ filter_baselines }}

# run NDPPP on the target data to flag, transfer calibrator values, and average
ndppp_prep_target.control.type                                 =   dppp
ndppp_prep_target.control.max_per_node                         =   {{ num_proc_per_node_limit }}
ndppp_prep_target.control.error_tolerance                      =   {{ error_tolerance }}
ndppp_prep_target.control.mapfiles_in                          =   [createmap_target.output.mapfile]
ndppp_prep_target.control.inputkeys                            =   [input_file]
ndppp_prep_target.argument.numthreads                          =   {{ max_dppp_threads }}
ndppp_prep_target.argument.msin                                =   input_file
ndppp_prep_target.argument.msin.datacolumn                     =   DATA
ndppp_prep_target.argument.msin.baseline                       =   check_station_mismatch.output.filter
ndppp_prep_target.argument.msout.datacolumn                    =   DATA
ndppp_prep_target.argument.msout.writefullresflag              =   False
ndppp_prep_target.argument.msout.overwrite                     =   True
ndppp_prep_target.argument.msout.storagemanager                =   "Dysco"
ndppp_prep_target.argument.msout.storagemanager.databitrate    =   0
ndppp_prep_target.argument.steps                               =   [flag,elev,flagamp,applyclock,applyPA,applybandpass,applybeam,applyRM,interp,avg]
ndppp_prep_target.argument.flag.type                           =   preflagger
ndppp_prep_target.argument.flag.baseline                       =   {{ flag_baselines }}
ndppp_prep_target.argument.elev.type                           =   preflagger
ndppp_prep_target.argument.elev.elevation                      =   0deg..20deg
# ndppp_prep_target.argument.filter.type                         =   filter
# ndppp_prep_target.argument.filter.baseline                     =   
# ndppp_prep_target.argument.filter.remove                       =   true                     # fully kick out the international stations.
ndppp_prep_target.argument.flagamp.type                        =   preflagger
ndppp_prep_target.argument.flagamp.amplmin                     =   1e-30
ndppp_prep_target.argument.applyclock.type                     =   applycal
ndppp_prep_target.argument.applyclock.parmdb                   =   {{ solutions }}
ndppp_prep_target.argument.applyclock.correction               =   clock000
ndppp_prep_target.argument.applyclock.solset                   =   calibrator
ndppp_prep_target.argument.applyPA.type                        =   applycal
ndppp_prep_target.argument.applyPA.parmdb                      =   {{ solutions }}
ndppp_prep_target.argument.applyPA.correction                  =   polalign
ndppp_prep_target.argument.applyPA.solset                      =   calibrator
ndppp_prep_target.argument.applybandpass.type                  =   applycal
ndppp_prep_target.argument.applybandpass.parmdb                =   {{ solutions }}
ndppp_prep_target.argument.applybandpass.correction            =   bandpass
ndppp_prep_target.argument.applybandpass.updateweights         =   True
ndppp_prep_target.argument.applybandpass.solset                =   calibrator
ndppp_prep_target.argument.applybeam.type                      =   applybeam
ndppp_prep_target.argument.applybeam.usechannelfreq            =   True
ndppp_prep_target.argument.applybeam.updateweights             =   True
ndppp_prep_target.argument.applyRM.type                        =   applycal
ndppp_prep_target.argument.applyRM.parmdb                      =   {{ solutions }}
ndppp_prep_target.argument.applyRM.correction                  =   RMextract
ndppp_prep_target.argument.applyRM.solset                      =   target
ndppp_prep_target.argument.interp.type                         =   interpolate
ndppp_prep_target.argument.interp.windowsize                   =   {{ interp_windowsize }}
ndppp_prep_target.argument.avg.type                            =   average
ndppp_prep_target.argument.avg.timeresolution                  =   {{ avg_timeresolution }}
ndppp_prep_target.argument.avg.freqresolution                  =   {{ avg_freqresolution }}


#############################
##     Clip A-Team         ##
#############################
# create a mapfile with the A-Team skymodel, length = 1
create_ateam_model_map.control.kind                            =   plugin
create_ateam_model_map.control.type                            =   addListMapfile
create_ateam_model_map.control.hosts                           =   ['localhost']
create_ateam_model_map.control.files                           =   [ {{ prefactor_directory }}/skymodels/Ateam_LBA_CC.skymodel ]
create_ateam_model_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_ateam_model_map.control.filename                        =   ateam_model_name.mapfile

# make sourcedbs from the A-Team skymodel, length = 1
make_sourcedb_ateam.control.kind                               =   recipe
make_sourcedb_ateam.control.type                               =   executable_args
make_sourcedb_ateam.control.executable                         =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_ateam.control.error_tolerance                    =   {{ error_tolerance }}
make_sourcedb_ateam.control.args_format                        =   lofar
make_sourcedb_ateam.control.outputkey                          =   out
make_sourcedb_ateam.control.mapfile_in                         =   create_ateam_model_map.output.mapfile
make_sourcedb_ateam.control.inputkey                           =   in
make_sourcedb_ateam.argument.format                            =   <
make_sourcedb_ateam.argument.outtype                           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_ateam.control.kind                             =   plugin
expand_sourcedb_ateam.control.type                             =   expandMapfile
expand_sourcedb_ateam.control.mapfile_in                       =   make_sourcedb_ateam.output.mapfile
expand_sourcedb_ateam.control.mapfile_to_match                 =   ndppp_prep_target.output.mapfile
expand_sourcedb_ateam.control.mapfile_dir                      =   input.output.mapfile_dir
expand_sourcedb_ateam.control.filename                         =   expand_sourcedb_ateam.datamap

# Predict, corrupt, and predict the ateam-resolution model, length = nfiles
predict_ateam.control.type                                     =   dppp
predict_ateam.control.mapfiles_in                              =   [ndppp_prep_target.output.mapfile,expand_sourcedb_ateam.output.mapfile]
predict_ateam.control.inputkeys                                =   [msin,sourcedb]
predict_ateam.control.inplace                                  =   True
predict_ateam.control.max_per_node                             =   {{ num_proc_per_node_limit }}
predict_ateam.control.error_tolerance                          =   {{ error_tolerance }}
predict_ateam.argument.numthreads                              =   {{ max_dppp_threads }}
predict_ateam.argument.msin.datacolumn                         =   DATA
# predict_ateam.argument.msin.baseline                           =   {{ filter_baselines }}
predict_ateam.argument.msout.datacolumn                        =   MODEL_DATA
predict_ateam.argument.msout.storagemanager                    =   "Dysco"
predict_ateam.argument.msout.storagemanager.databitrate        =   0
predict_ateam.argument.steps                                   =   [predict]
predict_ateam.argument.predict.type                            =   predict
predict_ateam.argument.predict.operation                       =   replace
predict_ateam.argument.predict.sourcedb                        =   sourcedb
predict_ateam.argument.predict.sources                         =   [VirA_4_patch,CygAGG,CasA_4_patch,TauAGG]
predict_ateam.argument.predict.usebeammodel                    =   True
predict_ateam.argument.predict.usechannelfreq                  =   false

# run the a-team clipper to flag data affected by the a-team
ateamcliptar.control.kind                                      =   recipe
ateamcliptar.control.type                                      =   executable_args
ateamcliptar.control.max_per_node                              =   {{ num_proc_per_node }}
ateamcliptar.control.executable                                =   {{ scripts }}/Ateamclipper.py
ateamcliptar.control.error_tolerance                           =   {{ error_tolerance }}
ateamcliptar.control.mapfile_in                                =   ndppp_prep_target.output.mapfile
ateamcliptar.control.arguments                                 =   [allms]
ateamcliptar.control.inputkey                                  =   allms


#############################
##     concatenate         ##
#############################
# combine all entries into one mapfile, for the sortmap script
combine_target_map.control.kind                                =   plugin
combine_target_map.control.type                                =   createMapfile
combine_target_map.control.method                              =   mapfile_all_to_one
combine_target_map.control.mapfile_dir                         =   input.output.mapfile_dir
combine_target_map.control.filename                            =   combine_target_map.mapfile
combine_target_map.control.mapfile_in                          =   ndppp_prep_target.output.mapfile

# sort the target data by frequency into groups so that NDPPP can concatenate them
sortmap_target.control.type                                    =   pythonplugin
sortmap_target.control.executable                              =   {{ scripts }}/sort_times_into_freqGroups.py
sortmap_target.argument.flags                                  =   [combine_target_map.output.mapfile]
sortmap_target.argument.filename                               =   sortmap_target
sortmap_target.argument.mapfile_dir                            =   input.output.mapfile_dir
sortmap_target.argument.target_path                            =   input.output.working_directory/input.output.job_name
sortmap_target.argument.numSB                                  =   {{ num_SBs_per_group }}
sortmap_target.argument.NDPPPfill                              =   True
sortmap_target.argument.stepname                               =   dpppconcat
sortmap_target.argument.firstSB                                =   {{ reference_stationSB }}
sortmap_target.argument.truncateLastSBs                        =   False

# convert the output of sortmap_target into usable mapfiles
do_sortmap_maps.control.kind                                   =   plugin
do_sortmap_maps.control.type                                   =   mapfilenamesFromMapfiles
do_sortmap_maps.control.mapfile_groupmap                       =   sortmap_target.output.groupmapfile.mapfile
do_sortmap_maps.control.mapfile_datamap                        =   sortmap_target.output.mapfile.mapfile

# run NDPPP to concatenate the target
dpppconcat.control.type                                        =   dppp
dpppconcat.control.max_per_node                                =   {{ num_proc_per_node_limit }}
dpppconcat.control.error_tolerance                             =   {{ error_tolerance }}
dpppconcat.control.mapfile_out                                 =   do_sortmap_maps.output.groupmap # tell the pipeline to give the output useful names
dpppconcat.control.mapfiles_in                                 =   [do_sortmap_maps.output.datamap]
dpppconcat.control.inputkey                                    =   msin
dpppconcat.argument.msin.datacolumn                            =   DATA
dpppconcat.argument.msin.missingdata                           =   True    #\ these two lines will make NDPPP generate dummy data when
dpppconcat.argument.msin.orderms                               =   False   #/ concatenating data
dpppconcat.argument.msout.datacolumn                           =   DATA
dpppconcat.argument.msout.writefullresflag                     =   False
dpppconcat.argument.msout.overwrite                            =   True
dpppconcat.argument.msout.storagemanager                       =   "Dysco"
dpppconcat.argument.msout.storagemanager.databitrate           =   0
dpppconcat.argument.steps                                      =   [interp,avg]
dpppconcat.argument.interp.type                                =   interpolate
dpppconcat.argument.interp.windowsize                          =   {{ interp_windowsize }}
dpppconcat.argument.avg.type                                   =   average
dpppconcat.argument.avg.timeresolution                         =   {{ avg_timeresolution_concat }}
dpppconcat.argument.avg.freqresolution                         =   {{ avg_freqresolution_concat }}

# combine all entries into one mapfile, for the sortmap script
combine_concat_map.control.kind                                =   plugin
combine_concat_map.control.type                                =   createMapfile
combine_concat_map.control.method                              =   mapfile_all_to_one
combine_concat_map.control.mapfile_dir                         =   input.output.mapfile_dir
combine_concat_map.control.filename                            =   combine_concat_map.mapfile
combine_concat_map.control.mapfile_in                          =   do_sortmap_maps.output.groupmap

# virtually concatenate target subbands
ms_concat_target.control.type                                  =   pythonplugin
ms_concat_target.control.executable                            =   {{ scripts }}/concat_MS.py
ms_concat_target.control.error_tolerance                       =   {{ error_tolerance }}
ms_concat_target.argument.filename                             =   concatmapfile.mapfile
ms_concat_target.argument.mapfile_dir                          =   input.output.mapfile_dir
ms_concat_target.argument.flags                                =   [combine_concat_map.output.mapfile,outputkey,{{ max_length }}]

# convert the output of ms_concat_target into usable mapfiles
ms_concat_target_map.control.kind                              =   plugin
ms_concat_target_map.control.type                              =   mapfilenamesFromMapfiles
ms_concat_target_map.control.mapfile_concatmap                 =   ms_concat_target.output.concatmapfile.mapfile

# run aoflagger on the concatenated data
aoflag.control.kind                                            =   recipe
aoflag.control.type                                            =   executable_args
aoflag.control.inplace                                         =   True
aoflag.control.executable                                      =   {{ aoflagger }}
aoflag.control.max_per_node                                    =   1
aoflag.control.error_tolerance                                 =   {{ error_tolerance }}
aoflag.control.mapfile_in                                      =   ms_concat_target_map.output.concatmap
aoflag.control.inputkey                                        =   msin
aoflag.control.args_format                                     =   wsclean
aoflag.argument.strategy                                       =   {{ lofar_directory }}/share/rfistrategies/{{ rfistrategy }}
aoflag.argument.flags                                          =   [-v,-memory-read,-combine-spws,msin]

#############################
##     phasecal target     ##
#############################
#check all files for minimum unflagged fraction
check_unflagged.control.type                                   =   pythonplugin
check_unflagged.control.executable                             =   {{ scripts }}/check_unflagged_fraction.py
check_unflagged.argument.flags                                 =   [dpppconcat.output.mapfile]
check_unflagged.argument.min_fraction                          =   {{ min_unflagged_fraction }}

# check potential station mismatch
check_bad_antennas.control.kind                                =   plugin
check_bad_antennas.control.type                                =   identifyBadAntennas
check_bad_antennas.control.mapfile_in                          =   do_sortmap_maps.output.groupmap
check_bad_antennas.control.filter                              =   {{ filter_baselines }}

# prune flagged files from mapfile
check_unflagged_map.control.kind                               =   plugin
check_unflagged_map.control.type                               =   pruneMapfile
check_unflagged_map.control.mapfile_in                         =   check_unflagged.output.flagged.mapfile
check_unflagged_map.control.mapfile_dir                        =   input.output.mapfile_dir
check_unflagged_map.control.filename                           =   check_unflagged_map.mapfile
check_unflagged_map.control.prune_str                          =   None

# if wished, download the tgss skymodel for the target
sky_tar.control.type                                           =   pythonplugin
sky_tar.control.executable                                     =   {{ scripts }}/download_tgss_skymodel_target.py
sky_tar.argument.flags                                         =   [combine_target_map.output.mapfile]
sky_tar.argument.DoDownload                                    =   {{ use_tgss_target }}
sky_tar.argument.SkymodelPath                                  =   {{ target_skymodel }}
sky_tar.argument.Radius                                        =   5. #in degrees

# create a mapfile with the target skymodel, length = 1
create_target_model_map.control.kind                           =   plugin
create_target_model_map.control.type                           =   addListMapfile
create_target_model_map.control.hosts                          =   ['localhost']
create_target_model_map.control.files                          =   [ {{ target_skymodel }} ]
create_target_model_map.control.mapfile_dir                    =   input.output.mapfile_dir
create_target_model_map.control.filename                       =   target_model_name.mapfile

# make sourcedbs from the target skymodel, length = 1
make_sourcedb_target.control.kind                              =   recipe
make_sourcedb_target.control.type                              =   executable_args
make_sourcedb_target.control.executable                        =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_target.control.error_tolerance                   =   {{ error_tolerance }}
make_sourcedb_target.control.args_format                       =   lofar
make_sourcedb_target.control.outputkey                         =   out
make_sourcedb_target.control.mapfile_in                        =   create_target_model_map.output.mapfile
make_sourcedb_target.control.inputkey                          =   in
make_sourcedb_target.argument.format                           =   <
make_sourcedb_target.argument.outtype                          =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_target.control.kind                            =   plugin
expand_sourcedb_target.control.type                            =   expandMapfile
expand_sourcedb_target.control.mapfile_in                      =   make_sourcedb_target.output.mapfile
expand_sourcedb_target.control.mapfile_to_match                =   check_unflagged_map.output.mapfile
expand_sourcedb_target.control.mapfile_dir                     =   input.output.mapfile_dir
expand_sourcedb_target.control.filename                        =   expand_sourcedb_target.datamap

# generate mapfile with the parmDB names to be used in the gsmcal steps
gsmcal_parmmap.control.kind                                    =   plugin
gsmcal_parmmap.control.type                                    =   createMapfile
gsmcal_parmmap.control.method                                  =   add_suffix_to_file
gsmcal_parmmap.control.mapfile_in                              =   check_unflagged_map.output.mapfile
gsmcal_parmmap.control.add_suffix_to_file                      =   .h5
gsmcal_parmmap.control.mapfile_dir                             =   input.output.mapfile_dir
gsmcal_parmmap.control.filename                                =   gsmcal_parmdbs.mapfile

# generate a mapfile with all files in a single entry
h5_gsmsol_map.control.kind                                     =   plugin
h5_gsmsol_map.control.type                                     =   compressMapfile
h5_gsmsol_map.control.mapfile_in                               =   gsmcal_parmmap.output.mapfile
h5_gsmsol_map.control.mapfile_dir                              =   input.output.mapfile_dir
h5_gsmsol_map.control.filename                                 =   h5_imp_gsmsol_map.mapfile

# # solve for and apply phase-only calibration solutions
# gsmcal_solve.control.type                                      =   dppp
# gsmcal_solve.control.error_tolerance                           =   {{ error_tolerance }}
# gsmcal_solve.control.inplace                                   =   True
# gsmcal_solve.control.max_per_node                              =   {{ num_proc_per_node_limit }}
# gsmcal_solve.control.mapfiles_in                               =   [check_unflagged_map.output.mapfile,expand_sourcedb_target.output.mapfile,gsmcal_parmmap.output.mapfile]
# gsmcal_solve.control.inputkeys                                 =   [input_file,sourcedb,parmdb]
# gsmcal_solve.argument.msin                                     =   input_file
# gsmcal_solve.argument.numthreads                               =   {{ max_dppp_threads }}
# gsmcal_solve.argument.msin.datacolumn                          =   DATA
# # gsmcal_solve.argument.msin.baseline                            =   {{ filter_baselines }}
# gsmcal_solve.argument.msout.datacolumn                         =   CORRECTED_DATA
# gsmcal_solve.argument.msout.storagemanager                     =   "Dysco"
# gsmcal_solve.argument.msout.storagemanager.databitrate         =   0
# gsmcal_solve.argument.steps                                    =   [filter,gaincal]
# gsmcal_solve.argument.filter.type                              =   filter
# gsmcal_solve.argument.filter.blrange                           =   [150, 999999]
# gsmcal_solve.argument.gaincal.type                             =   gaincal
# gsmcal_solve.argument.gaincal.maxiter                          =   50
# gsmcal_solve.argument.gaincal.caltype                          =   phaseonly
# gsmcal_solve.argument.gaincal.nchan                            =   0
# gsmcal_solve.argument.gaincal.solint                           =   1
# gsmcal_solve.argument.gaincal.sourcedb                         =   expand_sourcedb_target.output.mapfile
# gsmcal_solve.argument.gaincal.parmdb                           =   gsmcal_parmmap.output.mapfile
# gsmcal_solve.argument.gaincal.usebeammodel                     =   True
# gsmcal_solve.argument.gaincal.usechannelfreq                   =   True
# gsmcal_solve.argument.gaincal.beammode                         =   array_factor
# gsmcal_solve.argument.gaincal.applysolution                    =   True

# solve/store direction-independent phase-only self-calibration corrected UV-data to a fully Dysco compressed new MS
gsmcal_solve_dysco.control.type                                =   dppp
gsmcal_solve_dysco.control.error_tolerance                     =   {{ error_tolerance }}
gsmcal_solve_dysco.control.max_per_node                        =   {{ num_proc_per_node_limit }}
gsmcal_solve_dysco.control.mapfiles_in                         =   [check_unflagged_map.output.mapfile,make_results_mapfile.output.mapfile,expand_sourcedb_target.output.mapfile,gsmcal_parmmap.output.mapfile]
gsmcal_solve_dysco.control.inputkeys                           =   [input_file,output_file,sourcedb,parmdb]
gsmcal_solve_dysco.argument.msin                               =   input_file
gsmcal_solve_dysco.argument.numthreads                         =   {{ max_dppp_threads }}
gsmcal_solve_dysco.argument.msin.datacolumn                    =   DATA
gsmcal_solve_dysco.argument.msin.baseline                      =   check_bad_antennas.output.filter
gsmcal_solve_dysco.argument.msout                              =   output_file
gsmcal_solve_dysco.argument.msout.storagemanager               =   "Dysco"
gsmcal_solve_dysco.argument.steps                              =   [interp,filter,gaincal]
gsmcal_solve_dysco.argument.interp.type                        =   interpolate
gsmcal_solve_dysco.argument.interp.windowsize                  =   {{ interp_windowsize }}
gsmcal_solve_dysco.argument.filter.type                        =   filter
gsmcal_solve_dysco.argument.filter.blrange                     =   [150, 999999]
gsmcal_solve_dysco.argument.gaincal.type                       =   gaincal
gsmcal_solve_dysco.argument.gaincal.maxiter                    =   50
gsmcal_solve_dysco.argument.gaincal.caltype                    =   phaseonly
gsmcal_solve_dysco.argument.gaincal.nchan                      =   0
gsmcal_solve_dysco.argument.gaincal.solint                     =   1
gsmcal_solve_dysco.argument.gaincal.sourcedb                   =   sourcedb
gsmcal_solve_dysco.argument.gaincal.parmdb                     =   parmdb
gsmcal_solve_dysco.argument.gaincal.usebeammodel               =   True
gsmcal_solve_dysco.argument.gaincal.usechannelfreq             =   True
gsmcal_solve_dysco.argument.gaincal.beammode                   =   array_factor
gsmcal_solve_dysco.argument.gaincal.applysolution              =   True

###########################
## Analyze cal           ##
###########################
# collect all instrument tables into one h5parm
h5imp_gsmcal.control.kind                                      =   recipe
h5imp_gsmcal.control.type                                      =   executable_args
h5imp_gsmcal.control.executable                                =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_gsmcal.control.error_tolerance                           =   {{ error_tolerance }}
h5imp_gsmcal.control.mapfile_in                                =   h5_gsmsol_map.output.mapfile
h5imp_gsmcal.control.inputkey                                  =   h5in
h5imp_gsmcal.control.outputkey                                 =   outh5parm
h5imp_gsmcal.argument.flags                                    =   [-c,h5in]
h5imp_gsmcal.argument.outh5parm                                =   outh5parm

# create losoto v2 parset file
prepare_losoto_gsmcal.control.kind                             =   plugin
prepare_losoto_gsmcal.control.type                             =   makeLosotoParset
prepare_losoto_gsmcal.control.steps                            =   [plotP, plotP2, plotPd, plotPd2]
prepare_losoto_gsmcal.control.filename                         =   input.output.job_directory/losoto.parset
prepare_losoto_gsmcal.control.global.ncpu                      =   {{ num_proc_per_node }}
prepare_losoto_gsmcal.control.plotP.operation                  =   PLOT
prepare_losoto_gsmcal.control.plotP.soltab                     =   sol000/phase000
prepare_losoto_gsmcal.control.plotP.axesInPlot                 =   [time,freq]
prepare_losoto_gsmcal.control.plotP.axisInTable                =   ant
prepare_losoto_gsmcal.control.plotP.plotFlag                   =   True
prepare_losoto_gsmcal.control.plotP.prefix                     =   {{ inspection_directory }}/ph_
prepare_losoto_gsmcal.control.plotP.refAnt                     =   {{ refant }}
prepare_losoto_gsmcal.control.plotP.minmax                     =   [-3.14,3.14]
prepare_losoto_gsmcal.control.plotP2.operation                 =   PLOT
prepare_losoto_gsmcal.control.plotP2.soltab                    =   sol000/phase000
prepare_losoto_gsmcal.control.plotP2.axesInPlot                =   [time]
prepare_losoto_gsmcal.control.plotP2.axisInTable               =   ant
prepare_losoto_gsmcal.control.plotP2.axisInCol                 =   pol
prepare_losoto_gsmcal.control.plotP2.plotFlag                  =   True
prepare_losoto_gsmcal.control.plotP2.prefix                    =   {{ inspection_directory }}/ph_
prepare_losoto_gsmcal.control.plotP2.refAnt                    =   {{ refant }}
prepare_losoto_gsmcal.control.plotP2.minmax                    =   [-3.14,3.14]
prepare_losoto_gsmcal.control.plotPd.operation                 =   PLOT
prepare_losoto_gsmcal.control.plotPd.soltab                    =   sol000/phase000
prepare_losoto_gsmcal.control.plotPd.axesInPlot                =   [time,freq]
prepare_losoto_gsmcal.control.plotPd.axisInTable               =   ant
prepare_losoto_gsmcal.control.plotPd.axisDiff                  =   pol
prepare_losoto_gsmcal.control.plotPd.plotFlag                  =   True
prepare_losoto_gsmcal.control.plotPd.prefix                    =   {{ inspection_directory }}/ph_poldif
prepare_losoto_gsmcal.control.plotPd.refAnt                    =   {{ refant }}
prepare_losoto_gsmcal.control.plotPd.minmax                    =   [-3.14,3.14]
prepare_losoto_gsmcal.control.plotPd2.operation                =   PLOT
prepare_losoto_gsmcal.control.plotPd2.soltab                   =   sol000/phase000
prepare_losoto_gsmcal.control.plotPd2.axesInPlot               =   [time]
prepare_losoto_gsmcal.control.plotPd2.axisInTable              =   ant
prepare_losoto_gsmcal.control.plotPd2.axisDiff                 =   pol
prepare_losoto_gsmcal.control.plotPd2.plotFlag                 =   True
prepare_losoto_gsmcal.control.plotPd2.prefix                   =   {{ inspection_directory }}/ph_poldif_
prepare_losoto_gsmcal.control.plotPd2.refAnt                   =   {{ refant }}
prepare_losoto_gsmcal.control.plotPd2.minmax                   =   [-3.14,3.14]

# do the processing on the LoSoTo file
process_losoto_gsmcal.control.kind                             =   recipe
process_losoto_gsmcal.control.type                             =   executable_args
process_losoto_gsmcal.control.inplace                          =   True
process_losoto_gsmcal.control.executable                       =   {{ losoto_directory }}/bin/losoto
process_losoto_gsmcal.control.max_per_node                     =   {{ num_proc_per_node }}
process_losoto_gsmcal.control.mapfile_in                       =   h5imp_gsmcal.output.mapfile
process_losoto_gsmcal.control.inputkey                         =   h5in
process_losoto_gsmcal.argument.flags                           =   [h5in,{{ job_directory }}/losoto.parset]

# output the final soltab into an external h5parm
h5exp_gsmcal.control.kind                                      =   recipe
h5exp_gsmcal.control.type                                      =   executable_args
h5exp_gsmcal.control.inplace                                   =   True
h5exp_gsmcal.control.executable                                =   {{ losoto_directory }}/bin/H5parm_collector.py
h5exp_gsmcal.control.error_tolerance                           =   {{ error_tolerance }}
h5exp_gsmcal.control.mapfile_in                                =   h5imp_gsmcal.output.mapfile
h5exp_gsmcal.control.inputkey                                  =   h5in
h5exp_gsmcal.argument.flags                                    =   [h5in]
h5exp_gsmcal.argument.insoltab                                 =   phase000
h5exp_gsmcal.argument.outsolset                                =   target
h5exp_gsmcal.argument.outh5parm                                =   {{ solutions }}


################################
## final step (EXPERIMENTAL)  ##
################################
# make mapfile with the filenames of the results that we want
make_results_mapfile.control.kind                              =   plugin
make_results_mapfile.control.type                              =   makeResultsMapfile
make_results_mapfile.control.mapfile_dir                       =   input.output.mapfile_dir
make_results_mapfile.control.filename                          =   make_results_mapfile.mapfile
make_results_mapfile.control.mapfile_in                        =   check_unflagged_map.output.mapfile
make_results_mapfile.control.target_dir                        =   {{ results_directory }}
make_results_mapfile.control.make_target_dir                   =   True
make_results_mapfile.control.new_suffix                        =   .pre-cal.ms

# make mapfile with the filenames of the results that we want
make_results_mapfile2.control.kind                             =   plugin
make_results_mapfile2.control.type                             =   makeResultsMapfile
make_results_mapfile2.control.mapfile_dir                      =   input.output.mapfile_dir
make_results_mapfile2.control.filename                         =   make_results_mapfile2.mapfile
make_results_mapfile2.control.mapfile_in                       =   check_unflagged_map.output.mapfile
make_results_mapfile2.control.target_dir                       =   {{ results_directory }}
make_results_mapfile2.control.make_target_dir                  =   True
make_results_mapfile2.control.new_suffix                       =   .uncorr.ms

# move the results to where we want them
move_results.control.kind                                      =   recipe
move_results.control.type                                      =   executable_args
move_results.control.executable                                =   /bin/mv
move_results.control.max_per_node                              =   {{ num_proc_per_node_limit }}
move_results.control.mapfiles_in                               =   [check_unflagged_map.output.mapfile,make_results_mapfile2.output.mapfile]
move_results.control.inputkeys                                 =   [source,destination]
move_results.control.arguments                                 =   [source,destination]

########################################################
##                                                    ##
##                  END PIPELINE                      ##
##                                                    ##
########################################################
