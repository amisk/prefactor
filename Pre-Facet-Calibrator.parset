##########################################################################
# Pre-Facet Calibrator Calibration Pipeline                              #
#                                                                        #
# Calibrator part of the basic Pre-Facet calibration pipeline:           #
# - requires LOFAR software version  >= 3.1.0                            #
# - requires losoto software version >= 2.0.0                            #
# - expects shared filesystem, that all nodes can reach all files!       #
#   (E.g. a single workstation or compute cluster with shared filesystem #
#   doesn't work on multiple nodes on CEP3.)                             #
##########################################################################

##########################################
### parameters you will need to adjust. ##
##########################################

## information about the calibrator data
! cal_input_path           =  /data/scratch/drabent                  ## specify the directory where your calibrator data is stored
! cal_input_pattern        =  L228161*.MS                            ## regular expression pattern of all your calibrator files

## location of the software
! prefactor_directory      =  /home/drabent/prefactor/               ## path to your prefactor copy
! losoto_directory         =  /home/drabent/losoto                   ## path to your local LoSoTo installation

##########################################
### parameters you may need to adjust   ##
##########################################

! refant                   = 'CS001HBA0'                             ## name of the station that will be used as a reference for the phase-plots
! flag_baselines           =  []                                     ## NDPPP-compatible pattern for baselines or stations to be flagged (may be an empty list, i.e.: [] )
! do_smooth                =  False                                  ## enable or disable baseline-based smoothing
! rfistrategy              =  HBAdefault                             ## strategy to be applied with the statistical flagger (AOFlagger)

# definitions for pipeline options
! 1st_order                =  ct,plotTEC,residuals                   ## Do not change! Only cal_ion should be edited if needed
! 3rd_order                =  ct3,plotTEC3,residuals3                ## Do not change! Only cal_ion should be edited if needed
! cal_ion                  =  {{ 1st_order }}                        ## choose {{ 3rd_order }} if you want to include 3rd order ionospheric effects

##########################################
### parameters for pipeline performance ##
##########################################

! num_proc_per_node        =  input.output.max_per_node              ## number of processes to use per step per node (usually max_per_node from pipeline.cfg)
! num_proc_per_node_limit  =  4                                      ## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads         =  10                                     ## number of threads per process for NDPPP

! error_tolerance          =  False                                  ## set this to True if you want the pipeline run to continue if single bands fail

##########################################
### parameters you may want to adjust   ##
##########################################

## main directories
! lofar_directory          =  $LOFARROOT                             ## base directory of your LOFAR installation
! job_directory            =  input.output.job_directory             ## directory of the prefactor outputs

## script and plugin directories
! scripts                  =  {{ prefactor_directory }}/scripts
pipeline.pluginpath        =  {{ prefactor_directory }}/plugins

## skymodel directory
! calibrator_path_skymodel =  {{ prefactor_directory }}/skymodels

## result directories
! results_directory        =  {{ job_directory }}/results            ## location of the results
! inspection_directory     =  {{ results_directory }}/inspection     ## directory where the inspection plots will be stored
! cal_values_directory     =  {{ results_directory }}/cal_values     ## directory where the final h5parm solution set will be stored

## averaging for the calibrator data
! avg_timeresolution       =  4.        # average to 4 sec/timeslot
! avg_freqresolution       =  48.82kHz  # average to 48.82 kHz/ch (= 4 ch/SB)

########################################################
##                                                    ##
##    BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!  ##
##                                                    ##
########################################################

# which steps to run
pipeline.steps             =  [prep, PA, FR, bandpass, ion]


# pipeline substeps
pipeline.steps.prep        =  [mk_cal_values_dir, createmap_cal, ndppp_prep_cal, combine_data_cal_map, ms_concat, ndppp_flag, sky_cal, make_sourcedb, expand_sourcedb, predict_cal, calib_cal_parmmap, h5imp_cal_map]

pipeline.steps.PA          =  [smooth_data, calib_cal, h5imp_cal_PA, prepare_losoto_PA, process_losoto_PA, h5exp_cal_PA, h5exp_cal_map, expand_parmdb, apply_PA, apply_beam]
pipeline.steps.FR          =  [smooth_corrected, calib_cal, h5imp_cal_FR, prepare_losoto_FR, process_losoto_FR, h5exp_cal_FR, apply_FR]
pipeline.steps.bandpass    =  [smooth_corrected, calib_cal, h5imp_cal_bandpass, prepare_losoto_bandpass, process_losoto_bandpass, h5exp_cal_bandpass, apply_PA, apply_bandpass, apply_beam, apply_FR]
pipeline.steps.ion         =  [smooth_corrected, calib_cal, h5imp_cal_ion, prepare_losoto_ion, process_losoto_ion, h5exp_cal_ion]


#############################
## Prepare calibrator part ##
#############################
# create the cal_values_directory if needed
mk_cal_values_dir.control.kind                              =   plugin
mk_cal_values_dir.control.type                              =   makeDirectory
mk_cal_values_dir.control.directory                         =   {{ cal_values_directory }}

# generate a mapfile of all the calibrator data
createmap_cal.control.kind                                  =   plugin
createmap_cal.control.type                                  =   createMapfile
createmap_cal.control.method                                =   mapfile_from_folder
createmap_cal.control.mapfile_dir                           =   input.output.mapfile_dir
createmap_cal.control.filename                              =   createmap_cal.mapfile
createmap_cal.control.folder                                =   {{ cal_input_path }}
createmap_cal.control.pattern                               =   {{ cal_input_pattern }}

# run NDPPP on the calibrator data
ndppp_prep_cal.control.type                                 =   dppp
ndppp_prep_cal.control.max_per_node                         =   {{ num_proc_per_node_limit }}
ndppp_prep_cal.control.error_tolerance                      =   {{ error_tolerance }}
ndppp_prep_cal.argument.numthreads                          =   {{ max_dppp_threads }}
ndppp_prep_cal.argument.msin                                =   createmap_cal.output.mapfile    # The input data.
ndppp_prep_cal.argument.msin.datacolumn                     =   DATA
ndppp_prep_cal.argument.msin.baseline                       =   CS*&; RS*&; CS*&RS*
ndppp_prep_cal.argument.msout.datacolumn                    =   DATA
ndppp_prep_cal.argument.msout.writefullresflag              =   False
ndppp_prep_cal.argument.msout.overwrite                     =   True
ndppp_prep_cal.argument.msout.storagemanager                =   "Dysco"
ndppp_prep_cal.argument.msout.storagemanager.databitrate    =   0
ndppp_prep_cal.argument.msout.storagemanager.weightbitrate  =   12
ndppp_prep_cal.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
ndppp_prep_cal.argument.msout.storagemanager.disttruncation =   1.5
ndppp_prep_cal.argument.msout.storagemanager.normalization  =   "AF"
ndppp_prep_cal.argument.steps                               =   [flag,elev,flagamp,filter,avg]
ndppp_prep_cal.argument.flag.type                           =   preflagger
ndppp_prep_cal.argument.flag.baseline                       =   {{ flag_baselines }}
ndppp_prep_cal.argument.elev.type                           =   preflagger
ndppp_prep_cal.argument.elev.elevation                      =   0deg..20deg
ndppp_prep_cal.argument.filter.type                         =   filter
ndppp_prep_cal.argument.filter.baseline                     =   CS*, RS*&&
ndppp_prep_cal.argument.filter.remove                       =   true                     # fully kick out the international stations.
ndppp_prep_cal.argument.avg.type                            =   average
ndppp_prep_cal.argument.avg.timeresolution                  =   {{ avg_timeresolution }}
ndppp_prep_cal.argument.avg.freqresolution                  =   {{ avg_freqresolution }}
ndppp_prep_cal.argument.flagamp.type                        =   preflagger
ndppp_prep_cal.argument.flagamp.amplmin                     =   1e-30

# combine all entries into one mapfile (just for the find_skymodel_cal_auto script)
combine_data_cal_map.control.kind                           =   plugin
combine_data_cal_map.control.type                           =   createMapfile
combine_data_cal_map.control.method                         =   mapfile_all_to_one
combine_data_cal_map.control.mapfile_dir                    =   input.output.mapfile_dir
combine_data_cal_map.control.filename                       =   combine_data_cal_map.mapfile
combine_data_cal_map.control.mapfile_in                     =   ndppp_prep_cal.output.mapfile

# virtually concatenate calibrator subbands
ms_concat.control.type                                      =   pythonplugin
ms_concat.control.executable                                =   {{ scripts }}/concat_MS.py
ms_concat.control.error_tolerance                           =   {{ error_tolerance }}
ms_concat.argument.flags                                    =   [combine_data_cal_map.output.mapfile,outputkey]

# run NDPPP on the calibrator data
ndppp_flag.control.type                                     =   dppp
ndppp_flag.control.max_per_node                             =   {{ num_proc_per_node_limit }}
ndppp_flag.control.inplace                                  =   True
ndppp_flag.control.error_tolerance                          =   {{ error_tolerance }}
ndppp_flag.argument.numthreads                              =   {{ num_proc_per_node }}
ndppp_flag.argument.msin                                    =   ms_concat.output.mapfile    # The input data.
ndppp_flag.argument.msin.datacolumn                         =   DATA
ndppp_flag.argument.steps                                   =   [flag]
ndppp_flag.argument.flag.type                               =   aoflagger
ndppp_flag.argument.flag.keepstatistics                     =   True
ndppp_flag.argument.flag.strategy                           =   {{ lofar_directory }}/share/rfistrategies/{{ rfistrategy }}
ndppp_flag.argument.flag.memoryperc                         =   90

# find automatically the calibrator sky model
sky_cal.control.type                                        =   pythonplugin
sky_cal.control.executable                                  =   {{ scripts }}/find_skymodel_cal.py
sky_cal.control.error_tolerance                             =   {{ error_tolerance }}
sky_cal.argument.flags                                      =   [combine_data_cal_map.output.mapfile]
sky_cal.argument.DirSkymodelCal                             =   {{ calibrator_path_skymodel }}

# make the sourcedb
make_sourcedb.control.kind                                  =   recipe
make_sourcedb.control.type                                  =   executable_args
make_sourcedb.control.executable                            =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb.control.error_tolerance                       =   {{ error_tolerance }}
make_sourcedb.control.args_format                           =   lofar
make_sourcedb.control.outputkey                             =   out
make_sourcedb.control.mapfile_in                            =   sky_cal.output.SkymodelCal.mapfile
make_sourcedb.control.inputkey                              =   in
make_sourcedb.argument.format                               =   <
make_sourcedb.argument.outtype                              =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb.control.kind                                =   plugin
expand_sourcedb.control.type                                =   expandMapfile
expand_sourcedb.control.mapfile_in                          =   make_sourcedb.output.mapfile
expand_sourcedb.control.mapfile_to_match                    =   ndppp_prep_cal.output.mapfile
expand_sourcedb.control.mapfile_dir                         =   input.output.mapfile_dir
expand_sourcedb.control.filename                            =   expand_sourcedb.mapfile

# predict to save time
predict_cal.control.type                                    =   dppp
predict_cal.control.inplace                                 =   True
predict_cal.control.max_per_node                            =   {{ num_proc_per_node_limit }}
predict_cal.control.error_tolerance                         =   {{ error_tolerance }}
predict_cal.argument.numthreads                             =   {{ max_dppp_threads }}
predict_cal.argument.msin                                   =   ndppp_prep_cal.output.mapfile    # The input data.
predict_cal.argument.msin.datacolumn                        =   DATA
predict_cal.argument.msin.baseline                          =   [CR]S*&
predict_cal.argument.msout.datacolumn                       =   MODEL_DATA
predict_cal.argument.msout.storagemanager                   =   "Dysco"
predict_cal.argument.msout.storagemanager.databitrate       =   0
predict_cal.argument.msout.storagemanager.weightbitrate     =   12
predict_cal.argument.msout.storagemanager.distribution      =   "TruncatedGaussian"
predict_cal.argument.msout.storagemanager.disttruncation    =   1.5
predict_cal.argument.msout.storagemanager.normalization     =   "AF"
predict_cal.argument.steps                                  =   [predict]
predict_cal.argument.predict.type                           =   predict
predict_cal.argument.predict.sourcedb                       =   expand_sourcedb.output.mapfile
predict_cal.argument.predict.sources                        =   []
predict_cal.argument.predict.usebeammodel                   =   False # TODO: put to true for large sky
predict_cal.argument.predict.usechannelfreq                 =   False
predict_cal.argument.predict.beammode                       =   array_factor

# generate mapfile with the h5parm names to be used in the calib_cal steps
calib_cal_parmmap.control.kind                              =   plugin
calib_cal_parmmap.control.type                              =   createMapfile
calib_cal_parmmap.control.method                            =   add_suffix_to_file
calib_cal_parmmap.control.mapfile_in                        =   ndppp_prep_cal.output.mapfile
calib_cal_parmmap.control.add_suffix_to_file                =   /instrument.h5
calib_cal_parmmap.control.mapfile_dir                       =   input.output.mapfile_dir
calib_cal_parmmap.control.filename                          =   calib_cal_h5parms.mapfile

# generate a mapfile with all files in a single entry
h5imp_cal_map.control.kind                                  =   plugin
h5imp_cal_map.control.type                                  =   compressMapfile
h5imp_cal_map.control.mapfile_in                            =   calib_cal_parmmap.output.mapfile
h5imp_cal_map.control.mapfile_dir                           =   input.output.mapfile_dir
h5imp_cal_map.control.filename                              =   h5imp_cal_map.mapfile

# baseline-dependent smooting
smooth_data.control.type                                    =   executable_args
smooth_data.control.max_per_node                            =   {{ num_proc_per_node }}
smooth_data.control.error_tolerance                         =   {{ error_tolerance }}
smooth_data.control.executable                              =   {{ scripts }}/BLsmooth.py
smooth_data.argument.flags                                  =   [-c,{{ do_smooth }},-r,-i,DATA,-o,SMOOTHED_DATA,ndppp_prep_cal.output.mapfile]

# baseline-dependent smooting
smooth_corrected.control.type                               =   executable_args
smooth_corrected.control.max_per_node                       =   {{ num_proc_per_node }}
smooth_corrected.control.error_tolerance                    =   {{ error_tolerance }}
smooth_corrected.control.executable                         =   {{ scripts }}/BLsmooth.py
smooth_corrected.argument.flags                             =   [-c,{{ do_smooth }},-r,-i,CORRECTED_DATA,-o,SMOOTHED_DATA,ndppp_prep_cal.output.mapfile]

# now run NDPPP on the averaged calibrator data
calib_cal.control.type                                      =   dppp
calib_cal.control.inplace                                   =   True
calib_cal.control.max_per_node                              =   {{ num_proc_per_node_limit }}
calib_cal.control.error_tolerance                           =   {{ error_tolerance }}
calib_cal.argument.numthreads                               =   {{ max_dppp_threads }}
calib_cal.argument.msin                                     =   ndppp_prep_cal.output.mapfile    # The input data.
calib_cal.argument.msin.datacolumn                          =   SMOOTHED_DATA
calib_cal.argument.msin.baseline                            =   [CR]S*&
calib_cal.argument.steps                                    =   [solve]
calib_cal.argument.solve.type                               =   ddecal
calib_cal.argument.solve.mode                               =   rotation+diagonal
calib_cal.argument.solve.h5parm                             =   calib_cal_parmmap.output.mapfile
calib_cal.argument.solve.sourcedb                           =   expand_sourcedb.output.mapfile
# calib_cal.argument.solve.uvlambdamin                        =   160
calib_cal.argument.solve.uvlambdamin                        =   300
# calib_cal.argument.solve.uvlambdamax                        =   50000
calib_cal.argument.solve.maxiter                            =   500
# calib_cal.argument.solve.maxiter                          =   50
calib_cal.argument.solve.nchan                              =   1
calib_cal.argument.solve.solint                             =   1
calib_cal.argument.solve.propagatesolutions                 =   True
#calib_cal.argument.solve.usemodelcolumn                      = True
# calib_cal.argument.solve.usebeammodel                       =   True
# calib_cal.argument.solve.usechannelfreq                     =   False
# calib_cal.argument.solve.tolerance                          =   1e-10


###########################
## calibrate Pol. Align  ##
###########################
# collect all instrument tables into one h5parm
h5imp_cal_PA.control.kind                                   =   recipe
h5imp_cal_PA.control.type                                   =   executable_args
h5imp_cal_PA.control.executable                             =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_cal_PA.control.error_tolerance                        =   {{ error_tolerance }}
h5imp_cal_PA.control.outputkey                              =   outh5parm
h5imp_cal_PA.argument.flags                                 =   [-c,h5imp_cal_map.output.mapfile]
h5imp_cal_PA.argument.outh5parm                             =   outh5parm

# create losoto v2 parset file
prepare_losoto_PA.control.kind                              =   plugin
prepare_losoto_PA.control.type                              =   makeLosotoParset
prepare_losoto_PA.control.steps                             =   [plotP3,plotPd,flag,plotRot3,plotA3,bkp,align,plotAlign,residual,plotPr,plotPr2]
prepare_losoto_PA.control.filename                          =   input.output.job_directory/losoto.parset
prepare_losoto_PA.control.global.ncpu                       =   {{ num_proc_per_node }}
prepare_losoto_PA.control.plotP3.operation                  =   PLOT
prepare_losoto_PA.control.plotP3.soltab                     =   sol000/phase000
prepare_losoto_PA.control.plotP3.axesInPlot                 =   [time,freq]
prepare_losoto_PA.control.plotP3.axisInTable                =   ant
prepare_losoto_PA.control.plotP3.plotFlag                   =   True
prepare_losoto_PA.control.plotP3.prefix                     =   {{ inspection_directory }}/polalign_ph_
prepare_losoto_PA.control.plotP3.refAnt                     =   {{ refant }}
prepare_losoto_PA.control.plotPd.operation                  =   PLOT
prepare_losoto_PA.control.plotPd.soltab                     =   sol000/phase000
prepare_losoto_PA.control.plotPd.axesInPlot                 =   [time,freq]
prepare_losoto_PA.control.plotPd.axisInTable                =   ant
prepare_losoto_PA.control.plotPd.axisDiff                   =   pol
prepare_losoto_PA.control.plotPd.plotFlag                   =   True
prepare_losoto_PA.control.plotPd.prefix                     =   {{ inspection_directory }}/polalign_ph_poldif
prepare_losoto_PA.control.plotPd.refAnt                     =   {{ refant }}
prepare_losoto_PA.control.flag.operation                    =   REWEIGHT
prepare_losoto_PA.control.flag.flagBad                      =   True
prepare_losoto_PA.control.flag.soltab                       =   sol000/rotation000
prepare_losoto_PA.control.plotRot3.operation                =   PLOT
prepare_losoto_PA.control.plotRot3.soltab                   =   sol000/rotation000
prepare_losoto_PA.control.plotRot3.axesInPlot               =   [time,freq]
prepare_losoto_PA.control.plotRot3.axisInTable              =   ant
prepare_losoto_PA.control.plotRot3.plotFlag                 =   True
prepare_losoto_PA.control.plotRot3.prefix                   =   {{ inspection_directory }}/polalign_rotangle
prepare_losoto_PA.control.plotRot3.refAnt                   =   {{ refant }}
prepare_losoto_PA.control.plotA3.operation                  =   PLOT
prepare_losoto_PA.control.plotA3.soltab                     =   sol000/amplitude000
prepare_losoto_PA.control.plotA3.axesInPlot                 =   [time,freq]
prepare_losoto_PA.control.plotA3.axisInTable                =   ant
prepare_losoto_PA.control.plotA3.plotFlag                   =   True
prepare_losoto_PA.control.plotA3.prefix                     =   {{ inspection_directory }}/polalign_amp_
prepare_losoto_PA.control.bkp.operation                     =   DUPLICATE
prepare_losoto_PA.control.bkp.soltab                        =   sol000/phase000
prepare_losoto_PA.control.bkp.soltabOut                     =   phaseOrig000
prepare_losoto_PA.control.align.soltab                      =   sol000/phase000
prepare_losoto_PA.control.align.operation                   =   POLALIGN
prepare_losoto_PA.control.align.soltabOut                   =   polalign
prepare_losoto_PA.control.align.average                     =   True
prepare_losoto_PA.control.align.replace                     =   True
prepare_losoto_PA.control.align.fitOffset                   =   False
prepare_losoto_PA.control.align.refAnt                      =   {{ refant }}
prepare_losoto_PA.control.plotAlign.operation               =   PLOT
prepare_losoto_PA.control.plotAlign.soltab                  =   sol000/polalign
prepare_losoto_PA.control.plotAlign.axesInPlot              =   [time,freq]
prepare_losoto_PA.control.plotAlign.axisInTable             =   ant
prepare_losoto_PA.control.plotAlign.axisDiff                =   pol
prepare_losoto_PA.control.plotAlign.plotFlag                =   True
prepare_losoto_PA.control.plotAlign.prefix                  =   {{ inspection_directory }}/polalign
prepare_losoto_PA.control.plotAlign.refAnt                  =   {{ refant }}
prepare_losoto_PA.control.residual.operation                =   RESIDUALS
prepare_losoto_PA.control.residual.soltab                   =   sol000/phase000
prepare_losoto_PA.control.residual.soltabsToSub             =   polalign
prepare_losoto_PA.control.plotPr.operation                  =   PLOT
prepare_losoto_PA.control.plotPr.soltab                     =   sol000/phase000
prepare_losoto_PA.control.plotPr.axesInPlot                 =   [time,freq]
prepare_losoto_PA.control.plotPr.axisInTable                =   ant
prepare_losoto_PA.control.plotPr.axisDiff                   =   pol
prepare_losoto_PA.control.plotPr.plotFlag                   =   True
prepare_losoto_PA.control.plotPr.prefix                     =   {{ inspection_directory }}/polalign_ph-res_poldif
prepare_losoto_PA.control.plotPr.refAnt                     =   {{ refant }}
prepare_losoto_PA.control.plotPr2.operation                 =   PLOT
prepare_losoto_PA.control.plotPr2.soltab                    =   sol000/phase000
prepare_losoto_PA.control.plotPr2.axesInPlot                =   [time,freq]
prepare_losoto_PA.control.plotPr2.axisInTable               =   ant
prepare_losoto_PA.control.plotPr2.axisInCol                 =   pol
prepare_losoto_PA.control.plotPr2.plotFlag                  =   True
prepare_losoto_PA.control.plotPr2.prefix                    =   {{ inspection_directory }}/polalign_ph-res_
prepare_losoto_PA.control.plotPr2.refAnt                    =   {{ refant }}

# do the processing on the LoSoTo file
process_losoto_PA.control.kind                              =   recipe
process_losoto_PA.control.type                              =   executable_args
process_losoto_PA.control.executable                        =   {{ losoto_directory }}/bin/losoto
process_losoto_PA.control.max_per_node                      =   {{ num_proc_per_node }}
process_losoto_PA.argument.flags                            =   [h5imp_cal_PA.output.mapfile, input.output.job_directory/losoto.parset]

# output the final soltab into an external h5parm
h5exp_cal_PA.control.kind                                   =   recipe
h5exp_cal_PA.control.type                                   =   executable_args
h5exp_cal_PA.control.executable                             =   {{ losoto_directory }}/bin/H5parm_collector.py
h5exp_cal_PA.control.error_tolerance                        =   {{ error_tolerance }}
h5exp_cal_PA.argument.flags                                 =   [h5imp_cal_PA.output.mapfile]
h5exp_cal_PA.argument.insoltab                              =   polalign
h5exp_cal_PA.argument.outh5parm                             =   {{ cal_values_directory }}/cal_solutions.h5

# generate a mapfile of all the solutions
h5exp_cal_map.control.kind                                  =   plugin
h5exp_cal_map.control.type                                  =   createMapfile
h5exp_cal_map.control.method                                =   mapfile_from_folder
h5exp_cal_map.control.mapfile_dir                           =   input.output.mapfile_dir
h5exp_cal_map.control.filename                              =   cal_solutions.mapfile
h5exp_cal_map.control.folder                                =   {{ cal_values_directory }}
h5exp_cal_map.control.pattern                               =   cal_solutions.h5

# expand the parmdb mapfile so that there is one entry for every file, length = nfiles
expand_parmdb.control.kind                                  =   plugin
expand_parmdb.control.type                                  =   expandMapfile
expand_parmdb.control.mapfile_in                            =   h5exp_cal_map.output.mapfile
expand_parmdb.control.mapfile_to_match                      =   ndppp_prep_cal.output.mapfile
expand_parmdb.control.mapfile_dir                           =   input.output.mapfile_dir
expand_parmdb.control.filename                              =   expand_parmdb.mapfile


################################
## calibrate Farady Rotation  ##
################################
# collect all instrument tables into one h5parm
h5imp_cal_FR.control.kind                                   =   recipe
h5imp_cal_FR.control.type                                   =   executable_args
h5imp_cal_FR.control.executable                             =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_cal_FR.control.error_tolerance                        =   {{ error_tolerance }}
h5imp_cal_FR.control.outputkey                              =   outh5parm
h5imp_cal_FR.argument.flags                                 =   [-c,h5imp_cal_map.output.mapfile]
h5imp_cal_FR.argument.outh5parm                             =   outh5parm

# create losoto v2 parset file
prepare_losoto_FR.control.kind                              =   plugin
prepare_losoto_FR.control.type                              =   makeLosotoParset
prepare_losoto_FR.control.steps                             =   [plotP3,plotPd,flag,plotRot3,plotA3,faraday,plotFR]
prepare_losoto_FR.control.filename                          =   input.output.job_directory/losoto.parset
prepare_losoto_FR.control.global.ncpu                       =   {{ num_proc_per_node }}
prepare_losoto_FR.control.plotP3.operation                  =   PLOT
prepare_losoto_FR.control.plotP3.soltab                     =   sol000/phase000
prepare_losoto_FR.control.plotP3.axesInPlot                 =   [time,freq]
prepare_losoto_FR.control.plotP3.axisInTable                =   ant
prepare_losoto_FR.control.plotP3.plotFlag                   =   True
prepare_losoto_FR.control.plotP3.prefix                     =   {{ inspection_directory }}/fr_ph_
prepare_losoto_FR.control.plotP3.refAnt                     =   {{ refant }}
prepare_losoto_FR.control.plotPd.operation                  =   PLOT
prepare_losoto_FR.control.plotPd.soltab                     =   sol000/phase000
prepare_losoto_FR.control.plotPd.axesInPlot                 =   [time,freq]
prepare_losoto_FR.control.plotPd.axisInTable                =   ant
prepare_losoto_FR.control.plotPd.axisDiff                   =   pol
prepare_losoto_FR.control.plotPd.plotFlag                   =   True
prepare_losoto_FR.control.plotPd.prefix                     =   {{ inspection_directory }}/fr_ph_poldif
prepare_losoto_FR.control.plotPd.refAnt                     =   {{ refant }}
prepare_losoto_FR.control.flag.operation                    =   REWEIGHT
prepare_losoto_FR.control.flag.flagBad                      =   True
prepare_losoto_FR.control.flag.soltab                       =   sol000/rotation000
prepare_losoto_FR.control.plotRot3.operation                =   PLOT
prepare_losoto_FR.control.plotRot3.soltab                   =   sol000/rotation000
prepare_losoto_FR.control.plotRot3.axesInPlot               =   [time,freq]
prepare_losoto_FR.control.plotRot3.axisInTable              =   ant
prepare_losoto_FR.control.plotRot3.plotFlag                 =   True
prepare_losoto_FR.control.plotRot3.prefix                   =   {{ inspection_directory }}/fr_rotangle
prepare_losoto_FR.control.plotRot3.refAnt                   =   {{ refant }}
prepare_losoto_FR.control.plotA3.operation                  =   PLOT
prepare_losoto_FR.control.plotA3.soltab                     =   sol000/amplitude000
prepare_losoto_FR.control.plotA3.axesInPlot                 =   [time,freq]
prepare_losoto_FR.control.plotA3.axisInTable                =   ant
prepare_losoto_FR.control.plotA3.plotFlag                   =   True
prepare_losoto_FR.control.plotA3.prefix                     =   {{ inspection_directory }}/fr_amp_
prepare_losoto_FR.control.faraday.operation                 =   FARADAY
prepare_losoto_FR.control.faraday.soltab                    =   sol000/rotation000
prepare_losoto_FR.control.faraday.refAnt                    =   {{ refant }}
prepare_losoto_FR.control.faraday.maxResidual               =   1.
prepare_losoto_FR.control.plotFR.operation                  =   PLOT
prepare_losoto_FR.control.plotFR.soltab                     =   sol000/rotationmeasure000
prepare_losoto_FR.control.plotFR.axesInPlot                 =   [time]
prepare_losoto_FR.control.plotFR.axisInTable                =   ant
prepare_losoto_FR.control.plotFR.prefix                     =   {{ inspection_directory }}/fr

# do the processing on the LoSoTo file
process_losoto_FR.control.kind                              =   recipe
process_losoto_FR.control.type                              =   executable_args
process_losoto_FR.control.executable                        =   {{ losoto_directory }}/bin/losoto
process_losoto_FR.control.max_per_node                      =   {{ num_proc_per_node }}
process_losoto_FR.argument.flags                            =   [h5imp_cal_FR.output.mapfile, input.output.job_directory/losoto.parset]

# output the final soltab into an external h5parm
h5exp_cal_FR.control.kind                                   =   recipe
h5exp_cal_FR.control.type                                   =   executable_args
h5exp_cal_FR.control.executable                             =   {{ losoto_directory }}/bin/H5parm_collector.py
h5exp_cal_FR.control.error_tolerance                        =   {{ error_tolerance }}
h5exp_cal_FR.argument.flags                                 =   [h5imp_cal_FR.output.mapfile]
h5exp_cal_FR.argument.insoltab                              =   rotationmeasure000
h5exp_cal_FR.argument.outh5parm                             =   {{ cal_values_directory }}/cal_solutions.h5


################################
## calibrate bandpass         ##
################################
# collect all instrument tables into one h5parm
h5imp_cal_bandpass.control.kind                             =   recipe
h5imp_cal_bandpass.control.type                             =   executable_args
h5imp_cal_bandpass.control.executable                       =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_cal_bandpass.control.error_tolerance                  =   {{ error_tolerance }}
h5imp_cal_bandpass.control.outputkey                        =   outh5parm
h5imp_cal_bandpass.argument.flags                           =   [-c,h5imp_cal_map.output.mapfile]
h5imp_cal_bandpass.argument.outh5parm                       =   outh5parm

# create losoto v2 parset file
prepare_losoto_bandpass.control.kind                        =   plugin
prepare_losoto_bandpass.control.type                        =   makeLosotoParset
prepare_losoto_bandpass.control.steps                       =   [plotA1,flag,flagextend,plotA2,merge,bkp,bandpass,plotB1,plotB2]
prepare_losoto_bandpass.control.filename                    =   input.output.job_directory/losoto.parset
prepare_losoto_bandpass.control.global.ncpu                 =   {{ num_proc_per_node }}
prepare_losoto_bandpass.control.plotA1.operation            =   PLOT
prepare_losoto_bandpass.control.plotA1.soltab               =   sol000/amplitude000
prepare_losoto_bandpass.control.plotA1.axesInPlot           =   [time,freq]
prepare_losoto_bandpass.control.plotA1.axisInTable          =   ant
prepare_losoto_bandpass.control.plotA1.plotFlag             =   True
prepare_losoto_bandpass.control.plotA1.prefix               =   {{ inspection_directory }}/ampBFlag_
prepare_losoto_bandpass.control.flag.operation              =   FLAG
prepare_losoto_bandpass.control.flag.soltab                 =   sol000/amplitude000
prepare_losoto_bandpass.control.flag.axesToFlag             =   [time]
prepare_losoto_bandpass.control.flag.order                  =   [100] 
prepare_losoto_bandpass.control.flag.maxCycles              =   1
prepare_losoto_bandpass.control.flag.maxRms                 =   5
prepare_losoto_bandpass.control.flag.replce                 =   False
prepare_losoto_bandpass.control.flag.preFlagZeros           =   False
prepare_losoto_bandpass.control.flag.mode                   =   smooth
prepare_losoto_bandpass.control.flagextend.operation        =   FLAGEXTEND
prepare_losoto_bandpass.control.flagextend.soltab           =   sol000/amplitude000
prepare_losoto_bandpass.control.flagextend.axesToExt        =   [freq,time]
prepare_losoto_bandpass.control.flagextend.size             =   [50,100]
prepare_losoto_bandpass.control.flagextend.percent          =   50
prepare_losoto_bandpass.control.flagextend.maxCycles        =   3
prepare_losoto_bandpass.control.plotA2.operation            =   PLOT
prepare_losoto_bandpass.control.plotA2.soltab               =   sol000/amplitude000
prepare_losoto_bandpass.control.plotA2.axesInPlot           =   [time,freq]
prepare_losoto_bandpass.control.plotA2.axisInTable          =   ant
prepare_losoto_bandpass.control.plotA2.plotFlag             =   True
prepare_losoto_bandpass.control.plotA2.prefix               =   {{ inspection_directory }}/ampAFlag_
prepare_losoto_bandpass.control.merge.operation             =   REWEIGHT
prepare_losoto_bandpass.control.merge.mode                  =   copy
prepare_losoto_bandpass.control.merge.soltab                =   sol000/phase000
prepare_losoto_bandpass.control.merge.soltabImport          =   amplitude000
prepare_losoto_bandpass.control.bkp.operation               =   DUPLICATE
prepare_losoto_bandpass.control.bkp.soltab                  =   sol000/amplitude000
prepare_losoto_bandpass.control.bkp.soltabOut               =   amplitudeOrig000
prepare_losoto_bandpass.control.bandpass.operation          =   PREFACTOR_BANDPASS
prepare_losoto_bandpass.control.bandpass.soltab             =   sol000/amplitudeSmooth000
prepare_losoto_bandpass.control.bandpass.outSoltabName      =   bandpass000
prepare_losoto_bandpass.control.bandpass.BadSBList          =   ""
prepare_losoto_bandpass.control.bandpass.interpolate        =   True
prepare_losoto_bandpass.control.bandpass.removeTimeAxis     =   False
prepare_losoto_bandpass.control.bandpass.autoFlag           =   True
prepare_losoto_bandpass.control.bandpass.chanWidth          =   {{ avg_freqresolution }}
prepare_losoto_bandpass.control.plotB1.operation            =   PLOT
prepare_losoto_bandpass.control.plotB1.soltab               =   sol000/bandpass000
prepare_losoto_bandpass.control.plotB1.axesInPlot           =   [time,freq]
prepare_losoto_bandpass.control.plotB1.axisInTable          =   ant
prepare_losoto_bandpass.control.plotB1.plotFlag             =   True
prepare_losoto_bandpass.control.plotB1.prefix               =   {{ inspection_directory }}/bandpass_
prepare_losoto_bandpass.control.plotB2.operation            =   PLOT
prepare_losoto_bandpass.control.plotB2.soltab               =   sol000/bandpass000
prepare_losoto_bandpass.control.plotB2.axesInPlot           =   freq
prepare_losoto_bandpass.control.plotB2.axisInTable          =   ant
prepare_losoto_bandpass.control.plotB2.axisInCol            =   pol
prepare_losoto_bandpass.control.plotB2.plotFlag             =   True
prepare_losoto_bandpass.control.plotB2.prefix               =   {{ inspection_directory }}/bandpass_
prepare_losoto_bandpass.control.plotB2.time.minmaxstep      =   [0,1e20,500000]
prepare_losoto_bandpass.control.residualA.operation         =   RESIDUALS
prepare_losoto_bandpass.control.residualA.soltab            =   sol000/amplitude000
prepare_losoto_bandpass.control.residualA.soltabsToSub      =   bandpass000
prepare_losoto_bandpass.control.residualA.ratio             =   True
prepare_losoto_bandpass.control.plotAr3.operation           =   PLOT
prepare_losoto_bandpass.control.plotAr3.soltab              =   sol000/amplitude000
prepare_losoto_bandpass.control.plotAr3.axesInPlot          =   [time,freq]
prepare_losoto_bandpass.control.plotAr3.axisInTable         =   ant
prepare_losoto_bandpass.control.plotAr3.plotFlag            =   True
prepare_losoto_bandpass.control.plotAr3.prefix              =   {{ inspection_directory }}/ampRes_

# do the processing on the LoSoTo file
process_losoto_bandpass.control.kind                        =   recipe
process_losoto_bandpass.control.type                        =   executable_args
process_losoto_bandpass.control.executable                  =   {{ losoto_directory }}/bin/losoto
process_losoto_bandpass.control.max_per_node                =   {{ num_proc_per_node }}
process_losoto_bandpass.argument.flags                      =   [h5imp_cal_bandpass.output.mapfile, input.output.job_directory/losoto.parset]

# output the final soltab into an external h5parm
h5exp_cal_bandpass.control.kind                             =   recipe
h5exp_cal_bandpass.control.type                             =   executable_args
h5exp_cal_bandpass.control.executable                       =   {{ losoto_directory }}/bin/H5parm_collector.py
h5exp_cal_bandpass.control.error_tolerance                  =   {{ error_tolerance }}
h5exp_cal_bandpass.argument.flags                           =   [h5imp_cal_bandpass.output.mapfile]
h5exp_cal_bandpass.argument.insoltab                        =   bandpass000
h5exp_cal_bandpass.argument.outh5parm                       =   {{ cal_values_directory }}/cal_solutions.h5


################################
## calibrate ionosphere       ##
################################
# collect all instrument tables into one h5parm
h5imp_cal_ion.control.kind                                  =   recipe
h5imp_cal_ion.control.type                                  =   executable_args
h5imp_cal_ion.control.executable                            =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_cal_ion.control.error_tolerance                       =   {{ error_tolerance }}
h5imp_cal_ion.control.outputkey                             =   outh5parm
h5imp_cal_ion.argument.flags                                =   [-c,h5imp_cal_map.output.mapfile]
h5imp_cal_ion.argument.outh5parm                            =   outh5parm

# create losoto v2 parset file
prepare_losoto_ion.control.kind                             =   plugin
prepare_losoto_ion.control.type                             =   makeLosotoParset
prepare_losoto_ion.control.steps                            =   [plotA1,flag,flagextend,plotA2,merge,plotP3,plotPd,plotAi3,duplicatePbkp,{{ cal_ion }},plotClock,PlotPr3]
prepare_losoto_ion.control.filename                         =   input.output.job_directory/losoto.parset
prepare_losoto_ion.control.global.ncpu                      =   {{ num_proc_per_node }}
prepare_losoto_ion.control.plotA1.operation                 =   PLOT
prepare_losoto_ion.control.plotA1.soltab                    =   sol000/amplitude000
prepare_losoto_ion.control.plotA1.axesInPlot                =   [time,freq]
prepare_losoto_ion.control.plotA1.axisInTable               =   ant
prepare_losoto_ion.control.plotA1.plotFlag                  =   True
prepare_losoto_ion.control.plotA1.prefix                    =   {{ inspection_directory }}/ion_ampBFlag_
prepare_losoto_ion.control.flag.operation                   =   FLAG
prepare_losoto_ion.control.flag.soltab                      =   sol000/amplitude000
prepare_losoto_ion.control.flag.axesToFlag                  =   [time]
prepare_losoto_ion.control.flag.order                       =   [100] 
prepare_losoto_ion.control.flag.maxCycles                   =   1
prepare_losoto_ion.control.flag.maxRms                      =   5
prepare_losoto_ion.control.flag.replce                      =   False
prepare_losoto_ion.control.flag.preFlagZeros                =   False
prepare_losoto_ion.control.flag.mode                        =   smooth
prepare_losoto_ion.control.flagextend.operation             =   FLAGEXTEND
prepare_losoto_ion.control.flagextend.soltab                =   sol000/amplitude000
prepare_losoto_ion.control.flagextend.axesToExt             =   [freq,time]
prepare_losoto_ion.control.flagextend.size                  =   [50,100]
prepare_losoto_ion.control.flagextend.percent               =   50
prepare_losoto_ion.control.flagextend.maxCycles             =   3
prepare_losoto_ion.control.plotA2.operation                 =   PLOT
prepare_losoto_ion.control.plotA2.soltab                    =   sol000/amplitude000
prepare_losoto_ion.control.plotA2.axesInPlot                =   [time,freq]
prepare_losoto_ion.control.plotA2.axisInTable               =   ant
prepare_losoto_ion.control.plotA2.plotFlag                  =   True
prepare_losoto_ion.control.plotA2.prefix                    =   {{ inspection_directory }}/ion_ampAFlag_
prepare_losoto_ion.control.merge.operation                  =   REWEIGHT
prepare_losoto_ion.control.merge.mode                       =   copy
prepare_losoto_ion.control.merge.soltab                     =   sol000/phase000
prepare_losoto_ion.control.merge.soltabImport               =   amplitude000
prepare_losoto_ion.control.plotP3.operation                 =   PLOT
prepare_losoto_ion.control.plotP3.soltab                    =   sol000/phase000
prepare_losoto_ion.control.plotP3.axesInPlot                =   [time,freq]
prepare_losoto_ion.control.plotP3.axisInTable               =   ant
prepare_losoto_ion.control.plotP3.plotFlag                  =   True
prepare_losoto_ion.control.plotP3.prefix                    =   {{ inspection_directory }}/ion_ph_
prepare_losoto_ion.control.plotP3.refAnt                    =   {{ refant }}
prepare_losoto_ion.control.plotPd.operation                 =   PLOT
prepare_losoto_ion.control.plotPd.soltab                    =   sol000/phase000
prepare_losoto_ion.control.plotPd.axesInPlot                =   [time,freq]
prepare_losoto_ion.control.plotPd.axisInTable               =   ant
prepare_losoto_ion.control.plotPd.axisDiff                  =   pol
prepare_losoto_ion.control.plotPd.plotFlag                  =   True
prepare_losoto_ion.control.plotPd.prefix                    =   {{ inspection_directory }}/ion_ph_poldif
prepare_losoto_ion.control.plotPd.refAnt                    =   {{ refant }}
prepare_losoto_ion.control.plotAi3.operation                =   PLOT
prepare_losoto_ion.control.plotAi3.soltab                   =   sol000/amplitude000
prepare_losoto_ion.control.plotAi3.axesInPlot               =   [time,freq]
prepare_losoto_ion.control.plotAi3.axisInTable              =   ant
prepare_losoto_ion.control.plotAi3.plotFlag                 =   True
prepare_losoto_ion.control.plotAi3.prefix                   =   {{ inspection_directory }}/ion_amp_
prepare_losoto_ion.control.duplicatePbkp.operation          =   DUPLICATE
prepare_losoto_ion.control.duplicatePbkp.soltab             =   sol000/phase000
prepare_losoto_ion.control.duplicatePbkp.soltabOut          =   phaseOrig000
prepare_losoto_ion.control.ct.operation                     =   CLOCKTEC
prepare_losoto_ion.control.ct.soltab                        =   sol000/phase000
prepare_losoto_ion.control.ct.CombinePol                    =   True
prepare_losoto_ion.control.ct.FlagBadChannels               =   False
prepare_losoto_ion.control.ct.Fit3rdOrder                   =   False
prepare_losoto_ion.control.ct.Circular                      =   False
prepare_losoto_ion.control.ct3.operation                    =   CLOCKTEC
prepare_losoto_ion.control.ct3.soltab                       =   sol000/phase000
prepare_losoto_ion.control.ct3.CombinePol                   =   True
prepare_losoto_ion.control.ct3.FlagBadChannels              =   False
prepare_losoto_ion.control.ct3.Fit3rdOrder                  =   True
prepare_losoto_ion.control.ct3.Circular                     =   False
prepare_losoto_ion.control.plotClock.operation              =   PLOT
prepare_losoto_ion.control.plotClock.soltab                 =   sol000/clock000
prepare_losoto_ion.control.plotClock.axesInPlot             =   [time]
prepare_losoto_ion.control.plotClock.axisInTable            =   ant
prepare_losoto_ion.control.plotClock.prefix                 =   {{ inspection_directory }}/clock
prepare_losoto_ion.control.plotClock.plotFlag               =   False
prepare_losoto_ion.control.plotClock.refAnt                 =   {{ refant }}
prepare_losoto_ion.control.plotTEC.operation                =   PLOT
prepare_losoto_ion.control.plotTEC.soltab                   =   sol000/tec000
prepare_losoto_ion.control.plotTEC.axesInPlot               =   [time]
prepare_losoto_ion.control.plotTEC.axisInTable              =   ant
prepare_losoto_ion.control.plotTEC.prefix                   =   {{ inspection_directory }}/tec
prepare_losoto_ion.control.plotTEC.plotFlag                 =   False
prepare_losoto_ion.control.plotTEC.refAnt                   =   {{ refant }}
prepare_losoto_ion.control.plotTEC3.operation               =   PLOT
prepare_losoto_ion.control.plotTEC3.soltab                  =   sol000/tec3rd000
prepare_losoto_ion.control.plotTEC3.axesInPlot              =   [time]
prepare_losoto_ion.control.plotTEC3.axisInTable             =   ant
prepare_losoto_ion.control.plotTEC3.prefix                  =   plots/tec3rd
prepare_losoto_ion.control.plotTEC3.plotFlag                =   False
prepare_losoto_ion.control.plotTEC3.refAnt                  =   {{ refant }}
prepare_losoto_ion.control.residuals.operation              =   RESIDUALS
prepare_losoto_ion.control.residuals.soltab                 =   sol000/phase000
prepare_losoto_ion.control.residuals.soltabsToSub           =   [tec000,clock000]
prepare_losoto_ion.control.residuals3.operation             =   RESIDUALS
prepare_losoto_ion.control.residuals3.soltab                =   sol000/phase000
prepare_losoto_ion.control.residuals3.soltabsToSub          =   [tec000,clock000,tec3rd000] # only for very low-freq dataset
prepare_losoto_ion.control.PlotPr3.operation                =   PLOT
prepare_losoto_ion.control.PlotPr3.soltab                   =   sol000/phase000
prepare_losoto_ion.control.PlotPr3.axesInPlot               =   [time,freq]
prepare_losoto_ion.control.PlotPr3.axisInTable              =   ant
prepare_losoto_ion.control.PlotPr3.plotFlag                 =   True
prepare_losoto_ion.control.PlotPr3.prefix                   =   {{ inspection_directory }}/ion_phRes
prepare_losoto_ion.control.PlotPr3.refAnt                   =   {{ refant }}

# do the processing on the LoSoTo file
process_losoto_ion.control.kind                             =   recipe
process_losoto_ion.control.type                             =   executable_args
process_losoto_ion.control.executable                       =   {{ losoto_directory }}/bin/losoto
process_losoto_ion.control.max_per_node                     =   {{ num_proc_per_node }}
process_losoto_ion.argument.flags                           =   [h5imp_cal_ion.output.mapfile, input.output.job_directory/losoto.parset]

# output the final soltab into an external h5parm
h5exp_cal_ion.control.kind                                  =   recipe
h5exp_cal_ion.control.type                                  =   executable_args
h5exp_cal_ion.control.executable                            =   {{ losoto_directory }}/bin/H5parm_collector.py
h5exp_cal_ion.control.error_tolerance                       =   {{ error_tolerance }}
h5exp_cal_ion.argument.flags                                =   [h5imp_cal_ion.output.mapfile]
h5exp_cal_ion.argument.insoltab                             =   clock000
h5exp_cal_ion.argument.outh5parm                            =   {{ cal_values_directory }}/cal_solutions.h5

################################
## applying the results       ##
################################
# apply the PA solutions
apply_PA.control.type                                       =   dppp
apply_PA.control.error_tolerance                            =   {{ error_tolerance }}
apply_PA.control.inplace                                    =   True
apply_PA.control.max_per_node                               =   {{ num_proc_per_node_limit }}
apply_PA.control.mapfiles_in                                =   [ndppp_prep_cal.output.mapfile, expand_parmdb.output.mapfile]
apply_PA.control.inputkeys                                  =   [msin, applyPA.parmdb]
apply_PA.argument.numthreads                                =   {{ max_dppp_threads }}
apply_PA.argument.msin.datacolumn                           =   DATA
apply_PA.argument.msout.datacolumn                          =   CORRECTED_DATA
apply_PA.argument.msout.storagemanager                      =   "Dysco"
apply_PA.argument.msout.storagemanager.databitrate          =   0
apply_PA.argument.msout.storagemanager.weightbitrate        =   12
apply_PA.argument.msout.storagemanager.distribution         =   "TruncatedGaussian"
apply_PA.argument.msout.storagemanager.disttruncation       =   1.5
apply_PA.argument.msout.storagemanager.normalization        =   "AF"
apply_PA.argument.steps                                     =   [applyPA]
apply_PA.argument.applyPA.type                              =   applycal
apply_PA.argument.applyPA.correction                        =   polalign

# apply the bandpass
apply_bandpass.control.type                                 =   dppp
apply_bandpass.control.error_tolerance                      =   {{ error_tolerance }}
apply_bandpass.control.inplace                              =   True
apply_bandpass.control.max_per_node                         =   {{ num_proc_per_node_limit }}
apply_bandpass.control.mapfiles_in                          =   [ndppp_prep_cal.output.mapfile, expand_parmdb.output.mapfile]
apply_bandpass.control.inputkeys                            =   [msin, applybandpass.parmdb]
apply_bandpass.argument.numthreads                          =   {{ max_dppp_threads }}
apply_bandpass.argument.msin.datacolumn                     =   CORRECTED_DATA
apply_bandpass.argument.msout.datacolumn                    =   CORRECTED_DATA
apply_bandpass.argument.msout.storagemanager                =   "Dysco"
apply_bandpass.argument.msout.storagemanager.databitrate    =   0
apply_bandpass.argument.msout.storagemanager.weightbitrate  =   12
apply_bandpass.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
apply_bandpass.argument.msout.storagemanager.disttruncation =   1.5
apply_bandpass.argument.msout.storagemanager.normalization  =   "AF"
apply_bandpass.argument.steps                               =   [applybandpass]
apply_bandpass.argument.applybandpass.type                  =   applycal
apply_bandpass.argument.applybandpass.correction            =   bandpass000
apply_bandpass.argument.applybandpass.updateweights         =   True

# apply the beam
apply_beam.control.type                                     =   dppp
apply_beam.control.error_tolerance                          =   {{ error_tolerance }}
apply_beam.control.inplace                                  =   True
apply_beam.control.max_per_node                             =   {{ num_proc_per_node_limit }}
apply_beam.argument.numthreads                              =   {{ max_dppp_threads }}
apply_beam.argument.msin                                    =   ndppp_prep_cal.output.mapfile
apply_beam.argument.msin.datacolumn                         =   CORRECTED_DATA
apply_beam.argument.msout.datacolumn                        =   CORRECTED_DATA
apply_beam.argument.msout.storagemanager                    =   "Dysco"
apply_beam.argument.msout.storagemanager.databitrate        =   0
apply_beam.argument.msout.storagemanager.weightbitrate      =   12
apply_beam.argument.msout.storagemanager.distribution       =   "TruncatedGaussian"
apply_beam.argument.msout.storagemanager.disttruncation     =   1.5
apply_beam.argument.msout.storagemanager.normalization      =   "AF"
apply_beam.argument.steps                                   =   [applybeam]
apply_beam.argument.applybeam.type                          =   applybeam
apply_beam.argument.applybeam.invert                        =   True
apply_beam.argument.applybeam.usechannelfreq                =   False
apply_beam.argument.applybeam.beammode                      =   element
apply_beam.argument.applybeam.updateweights                 =   True

# apply the FR solutions
apply_FR.control.type                                       =   dppp
apply_FR.control.error_tolerance                            =   {{ error_tolerance }}
apply_FR.control.inplace                                    =   True
apply_FR.control.max_per_node                               =   {{ num_proc_per_node_limit }}
apply_FR.control.mapfiles_in                                =   [ndppp_prep_cal.output.mapfile, expand_parmdb.output.mapfile]
apply_FR.control.inputkeys                                  =   [msin, applyFR.parmdb]
apply_FR.argument.numthreads                                =   {{ max_dppp_threads }}
apply_FR.argument.msin.datacolumn                           =   CORRECTED_DATA
apply_FR.argument.msout.datacolumn                          =   CORRECTED_DATA
apply_FR.argument.msout.storagemanager                      =   "Dysco"
apply_FR.argument.msout.storagemanager.databitrate          =   0
apply_FR.argument.msout.storagemanager.weightbitrate        =   12
apply_FR.argument.msout.storagemanager.distribution         =   "TruncatedGaussian"
apply_FR.argument.msout.storagemanager.disttruncation       =   1.5
apply_FR.argument.msout.storagemanager.normalization        =   "AF"
apply_FR.argument.steps                                     =   [applyFR]
apply_FR.argument.applyFR.type                              =   applycal
apply_FR.argument.applyFR.correction                        =   rotationmeasure000

########################################################
##                                                    ##
##                  END PIPELINE                      ##
##                                                    ##
########################################################
